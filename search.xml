<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>React.lazy初体验</title>
      <link href="/2019/12/19/React-lazy/"/>
      <content type="html"><![CDATA[<p>React.lazy初体验</p><a id="more"></a><h1 id="React-lazy项目实践"><a href="#React-lazy项目实践" class="headerlink" title="React.lazy项目实践"></a>React.lazy项目实践</h1><p>React16.6于2018年10月份发布，该版本带来了许多新的特性同时赋予给React更强大的功能。其中最为显著的两个特性是<code>React.Suspense</code>和<code>React.lazy</code>。这两个特性，将React的代码分割和懒加载带到了一个新的高度。使用这两个特性，你可以做到的是在真正需要时才加载该组件的文件。</p><p>本文主要介绍我在项目中如何使用<code>React.Suspense</code>和<code>React.lazy</code>以及该特性给我们React开发者带来的好处。</p><h2 id="为什么要使用代码分割"><a href="#为什么要使用代码分割" class="headerlink" title="为什么要使用代码分割"></a>为什么要使用代码分割</h2><p>随着前端技术的不断发展，ES6模块、Babel转换、webpack打包等新技术的出现，前端应用现在完全可以使用模块化的方式完成，便于维护。<br>通常情况下，我们会将所有的模块打包到一个文件中，当请求网页时加载该文件以展示整个应用。但是，随着网页功能的不断扩展，这便带来了网页加载缓慢、交互卡顿等问题，使用户体验非常糟糕。<br>导致这一问题的主要原因是，我们在页面加载时，会一次性加载所有代码，无论是当前要用的代码还是之后用到的代码。但是用户在第一次进来时并不会用到所有的功能，因此<code>code-splitting</code>即代码分割这个名词出现了。</p><p>像webpack便提供了代码分割的功能。webpack中对代码分割的定义如下：</p><blockquote><p>Code splitting is one of the most compelling features of webpack. This feature allows you to split your code into various bundles which can then be loaded on demand or in parallel.</p></blockquote><p>意思就是说可以将代码拆分为多个bundle，同时可以按需或者并行加载。因此，为了提高应用的性能，我们可以尝试如何合理的分割代码并延迟加载。</p><h2 id="如何分割代码？"><a href="#如何分割代码？" class="headerlink" title="如何分割代码？"></a>如何分割代码？</h2><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>ES6标准引入了import以方便我们静态加载模块。形式如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import xxx from xxx.js</span><br></pre></td></tr></table></figure></p><p>尽管import对于我们加载模块很有帮助，但是静态加载模块的方式一定程度上限制了我们来实现异步模块加载。不过，目前动态加载模块的import()语法已处于提案阶段，并且webpack已将他引入并使用。import()提供了基于Promise的API，因此，import()的返回值是一个完成状态或拒绝状态的Promise对象。形式如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import(/* webpackChunkName: &apos;module&apos;*/ &quot;module&quot;)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;)</span><br><span class="line">.catch(_ =&gt; console.log(&apos;It is an error&apos;))</span><br></pre></td></tr></table></figure></p><p>webpack在编译时，识别到动态加载的import语法，则webpack会为当前动态加载的模块创建一个单独的bundle。如果你使用的是官方的Create-react-app脚手架或React的服务端渲染框架Next.js，那么可以直接使用动态import语法。如果你的脚手架是你自己配置的webpack，那么你需要按照官方指南来设置，请移步[1]。</p><h3 id="动态加载React组件"><a href="#动态加载React组件" class="headerlink" title="动态加载React组件"></a>动态加载React组件</h3><p>当前最为流行的一种方法是使用<code>React-loadable</code>[2]库提供的懒加载React组件。它利用import()语法，使用Promise语法加载React组件。同时，React-loadable支持React的服务端渲染。<br>通常，我们以如下方式实现组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import LazyComponet from &apos;LazyComponent&apos;;</span><br><span class="line"></span><br><span class="line">export default function DemoComponent() &#123;</span><br><span class="line">return (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;demo component&lt;/p&gt;</span><br><span class="line">&lt;AComponent /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，假设<code>LazyComponet</code>在<code>DemoComponent</code>渲染时我们并不展示。但是因为我们使用import语法将<code>LazyComponet</code>导入，所以在编译时会将<code>LazyComponet</code>的代码与<code>DemoComponent</code>的代码打包到同一个bundle里面。<br>但是，这并不是我们想要的。所以我们可以通过使用<code>React-loadable</code>来懒加载<code>LazyComponet</code>，同时将<code>LazyComponet</code>的代码单独打包到一个bundle里面。我们可以看一下官网提供的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Loadable from &apos;react-loadable&apos;;</span><br><span class="line">import Loading from &apos;./my-loading-component&apos;;</span><br><span class="line"></span><br><span class="line">const LoadableComponent = Loadable(&#123;</span><br><span class="line">  loader: () =&gt; import(&apos;./my-component&apos;),</span><br><span class="line">  loading: Loading,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;LoadableComponent/&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从例子中我们可以看到，react-loadable使用动态import()方法，并将导入的组件分配给loader属性。同时，react-loadable提供了一个loading属性，以设置在加载组件时将展示的组件。</p><h2 id="React-lazy和React-suspense的使用"><a href="#React-lazy和React-suspense的使用" class="headerlink" title="React.lazy和React.suspense的使用"></a>React.lazy和React.suspense的使用</h2><blockquote><p>React.lazy and Suspense is not yet available for server-side rendering. If you want to do code-splitting in a server rendered app, we recommend Loadable Components. It has a nice guide for bundle splitting with server-side rendering.</p></blockquote><p>在使用之前，我们需要特别注意的一点是，React官方明确支持，React.lazy和Suspense并不支持服务端渲染。因此，使用服务端渲染的同学，请绕行至<code>react-loadable</code>和<code>loadable-components</code>[3]。</p><p>由于我是对原有项目进行的升级，因此，本文以下内容主要针对于老项目升级React最新版所做的工作。</p><h3 id="代码升级React最新版"><a href="#代码升级React最新版" class="headerlink" title="代码升级React最新版"></a>代码升级React最新版</h3><p>如果你的代码是Reactv16，那么可以直接升级到最新版本，当然React16.6已经提供了lazy和suspense方法。如果是v16之前，则按照官方操作迁移。</p><h3 id="确定原有代码的懒加载组件"><a href="#确定原有代码的懒加载组件" class="headerlink" title="确定原有代码的懒加载组件"></a>确定原有代码的懒加载组件</h3><p>首先，按照需求，将非首屏加载的组件确定为懒加载组件，我的项目共确定五个组件可以进行懒加载。修改方式很简单，原有引入组件的方法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import LazyComponent from &quot;../components/LazyComponent &quot;;</span><br></pre></td></tr></table></figure></p><p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const LazyComponent = React.lazy(() =&gt;</span><br><span class="line">  import(/* webpackChunkName: &apos;lazyComponent&apos;*/ &quot;../components/LazyComponent&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>如代码所示：将静态引用组件的代码替换为调用React.lazy()，在lazy()传入一个匿名函数作为参数，在函数中动态引入<code>lazyComponent</code>组件。这样在我们渲染这个组件前，浏览器将不会下载<code>lazyComponent .bundle.js</code>文件和它的依赖。<br>其中，import内的webpackChunkName为我们定义的bundle文件名。</p><p>如果React要渲染<lazycomponent>组件时，组件依赖的代码还没下载好，会出现什么情况？<code>&lt;React.Suspense/&gt;</code>的出现帮我们解决问题。在代码未下载好前，它将会渲染fallback属性传入的值。因此我们的原有代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;MainComponet /&gt;</span><br><span class="line">&lt;LazyComponent /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></lazycomponent></p><p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;MainComponet /&gt;</span><br><span class="line">&lt;React.Suspense fallback=&#123;&lt;div&gt;正在加载中&lt;/div&gt;&#125;&gt;</span><br><span class="line">&lt;LazyComponent /&gt;</span><br><span class="line">&lt;/React.Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>fallback中可以修改为任意的spinner，本次不做过多优化。假如你不使用React.suspense，则React会给出你错误提示，因此记得React.lazy和React.Suspense搭配使用。<br>此时我们可以看一下我们的网络请求。</p><p><img src="//img13.360buyimg.com/imagetools/jfs/t1/9488/17/12539/50538/5c383739Eee1219ea/ea8d36833b1aba13.gif" alt="enter image description here"></p><p>从图中我们可以看到，我们动态加载的lazyComponet组件被单独打包到一个bundle里面，然而，在首屏加载的时候，该bundle已经加载到我们的页面中了，这也许并不是我们想要的，我们想要的是当我们需要的时候再加载。接下来我们就控制一下，当我们需要的时候，再加载该文件。</p><h3 id="通过变量控制加载"><a href="#通过变量控制加载" class="headerlink" title="通过变量控制加载"></a>通过变量控制加载</h3><p>原本我选择的五个懒加载组件均属于弹层性质的组件，因此必然会设置一个state来控制该组件的显示与隐藏，因此我们将代码改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;MainComponet /&gt;</span><br><span class="line">        &#123;this.state.showLazyComponent &amp;&amp; (</span><br><span class="line">&lt;React.Suspense fallback=&#123;&lt;div&gt;正在加载中&lt;/div&gt;&#125;&gt;</span><br><span class="line">&lt;LazyComponent /&gt;</span><br><span class="line">&lt;/React.Suspense&gt;</span><br><span class="line">        )&#125;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>此时我们可以看一下网络请求。</p><p><img src="//img14.360buyimg.com/imagetools/jfs/t1/25086/27/5072/67131/5c383a4cE91ba0b6b/e849428313845521.gif" alt="enter image description here"></p><p>从图中可以看出，在首屏加载时，并未加载我们的懒加载组件<code>LazyComponent</code>所对应的bundle包。等到我们点击需要该组件显示时，页面才去加载该js。这便达到了我们代码分离并懒加载的目的。那么我们这么操作，到底主bundle包的体积减少了吗？接下来我们打包文件看一下。</p><h3 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h3><p>拆分前打包出来的文件：</p><p><img src="https://img13.360buyimg.com/imagetools/s300x200_jfs/t1/28390/34/4992/10082/5c38410eE533f55c6/8915f5f1c91ba377.png" alt="Alt text"></p><p>拆分后打包出来的文件：</p><p><img src="https://img12.360buyimg.com/imagetools/s300x200_jfs/t1/29192/40/5051/17797/5c3843bbE666b8599/5dcbe33ba7394dea.png" alt="Alt text"></p><p><code>app.js</code>文件变小，随之增加<code>lazyComponent.js</code>。当懒加载组件多时，我们便可一定程度上减少首屏加载文件的大小，提高首屏的渲染速度。</p><h2 id="浏览器参数对比"><a href="#浏览器参数对比" class="headerlink" title="浏览器参数对比"></a>浏览器参数对比</h2><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><p>拆分前：</p><p><img src="https://img12.360buyimg.com/imagetools/s800x50_jfs/t1/27307/16/4955/6028/5c3844d4E12c89716/98dd4c2789326821.png" alt="Alt text"></p><p>拆分后：</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="https://img12.360buyimg.com/imagetools/s800x50_jfs/t1/26281/26/5092/6266/5c3844d4Ef9508d8b/5514d5c40ebc99c0.png" class="lazyload"></p><h3 id="performance-summary"><a href="#performance-summary" class="headerlink" title="performance summary"></a>performance summary</h3><p>拆分前：</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="https://img12.360buyimg.com/imagetools/s374x224_jfs/t1/30803/7/152/16527/5c3844d4Eb5ac53ee/f53366e45a575a43.png" class="lazyload"></p><p>拆分后：</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="https://img12.360buyimg.com/imagetools/s374x224_jfs/t1/24426/26/4932/15891/5c3844d4E5fcd0052/c16f0bfd9111237d.png" class="lazyload"></p><ul><li>蓝色：加载（Loading）时间降低</li><li>黄色：脚本运算（Scripting）时间降低</li><li>紫色：渲染（Rendering）时间降低</li><li>绿色：绘制（Painting）时间持平</li><li>灰色：其他（Other）时间降低</li><li>闲置：浏览器空闲时间降低</li></ul><h3 id="接口请求时间"><a href="#接口请求时间" class="headerlink" title="接口请求时间"></a>接口请求时间</h3><p>拆分前：</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/22659/6/5006/18218/5c3844d4Ef3cc1c74/d59c6db4987c3255.png" class="lazyload"></p><p><img src="/images/placeholder.png" alt="Alt text" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/9441/30/12808/11637/5c3844d4E80ba7926/e6e3a6d52acfca1f.png" class="lazyload"></p><p>拆分后：</p><p><img src="/images/placeholder.png" alt="Alt text" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/15109/9/5148/19186/5c3844d4E522a772b/199b9777d57ff485.png" class="lazyload"></p><p><img src="/images/placeholder.png" alt="Alt text" data-src="https://img12.360buyimg.com/imagetools/jfs/t1/16405/40/5000/16430/5c3844d4Ec9b81926/aa69cf435d7050b0.png" class="lazyload"></p><p>从图中可以看出，拆分后接口请求数据时间提前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从多项数据表明，<code>React.lazy</code>和<code>React.Suspense</code>的使用一定程度上加快了首屏的渲染速度，使得我们的页面加载更快。<br>另外，当我们想添加一个新功能而引入一个新依赖时，我们往往会评估该依赖的大小以及引入该依赖会对原有bundle造成多大影响。假如该功能很少被用到，那么我们可以痛快地使用<code>React.lazy</code>和<code>React.Suspense</code>来按需加载该功能，而无需牺牲用户体验了。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>[1] <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">https://webpack.js.org/guides/code-splitting/</a><br>[2] <a href="https://github.com/jamiebuilds/react-loadable" target="_blank" rel="noopener">https://github.com/jamiebuilds/react-loadable</a><br>[3] <a href="https://github.com/smooth-code/loadable-components" target="_blank" rel="noopener">https://github.com/smooth-code/loadable-components</a></p>]]></content>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每日一文2019</title>
      <link href="/2019/12/19/dailyArtical2019/"/>
      <content type="html"><![CDATA[<h3 id="2019年第1周"><a href="#2019年第1周" class="headerlink" title="2019年第1周"></a>2019年第1周</h3><ul><li><strong>20190102 <a href="https://juejin.im/post/5c288546e51d451a6b51554a" target="_blank" rel="noopener">那些你不知道的meta标签</a></strong></li><li><strong>20190103 <a href="http://www.cnblogs.com/coco1s/p/10137045.html" target="_blank" rel="noopener">探究 CSS 混合模式\滤镜导致 CSS 3D 失效问题</a></strong></li><li><strong>20190104 <a href="https://github.com/LeuisKen/leuisken.github.io/issues/2" target="_blank" rel="noopener">为什么我认为数据结构与算法对前端开发很重要？</a></strong><a id="more"></a></li></ul><h3 id="2019年第1周-1"><a href="#2019年第1周-1" class="headerlink" title="2019年第1周"></a>2019年第1周</h3><ul><li><strong>20190102 <a href="https://juejin.im/post/5c288546e51d451a6b51554a" target="_blank" rel="noopener">那些你不知道的meta标签</a></strong></li><li><strong>20190103 <a href="http://www.cnblogs.com/coco1s/p/10137045.html" target="_blank" rel="noopener">探究 CSS 混合模式\滤镜导致 CSS 3D 失效问题</a></strong></li><li><strong>20190104 <a href="https://github.com/LeuisKen/leuisken.github.io/issues/2" target="_blank" rel="noopener">为什么我认为数据结构与算法对前端开发很重要？</a></strong></li></ul><h3 id="2019年第2周"><a href="#2019年第2周" class="headerlink" title="2019年第2周"></a>2019年第2周</h3><ul><li><strong>20190107 <a href="https://juejin.im/post/5c31a45df265da61193bfc7e" target="_blank" rel="noopener">[译] React 16.6 懒加载(与预加载)组件</a></strong></li><li><strong>20190108 <a href="https://mp.weixin.qq.com/s/EjALJJiYPcJ5HdPu0SRghg" target="_blank" rel="noopener">你真的会拆分代码吗？</a></strong></li><li><strong>20190108 <a href="https://juejin.im/post/5aedd4a2f265da0b9d781b85" target="_blank" rel="noopener">如何实现一个HTTP请求库——axios源码阅读与分析</a></strong></li><li><strong>20190110 <a href="https://juejin.im/post/5b8ca0fbf265da436f59103c" target="_blank" rel="noopener">五分钟 Styled-components 高级实用技巧</a></strong></li></ul><h3 id="2019年第3周"><a href="#2019年第3周" class="headerlink" title="2019年第3周"></a>2019年第3周</h3><ul><li><strong>20190114 <a href="https://segmentfault.com/a/1190000014129037" target="_blank" rel="noopener">Webpack 将代码打包成什么样子？</a></strong></li><li><strong>20190115 <a href="https://mp.weixin.qq.com/s/U5RcBUkTWSiazQquTjFeHQ" target="_blank" rel="noopener">GitHub年度盘点：Deno赶超Node，跃升第四！</a></strong></li><li><strong>20190116 <a href="https://juejin.im/post/5c37fe8451882523995df8e8" target="_blank" rel="noopener">2018 年「掘金翻译计划」年度总结：我们共同的成长故事</a></strong></li><li><strong>20190117 <a href="http://jartto.wang/2018/12/31/f2e-2018/" target="_blank" rel="noopener">用 Python 爬取 2018 前端热点</a></strong></li><li><strong>20190118 <a href="https://segmentfault.com/a/1190000017814080" target="_blank" rel="noopener">从 loading 的 9 种写法谈 React 业务开发</a></strong></li></ul><h3 id="2019年第4周"><a href="#2019年第4周" class="headerlink" title="2019年第4周"></a>2019年第4周</h3><ul><li><strong>20190121 <a href="https://zhuanlan.zhihu.com/p/55294150" target="_blank" rel="noopener">世界是平的吗？——从不同角度看前端</a></strong></li><li><strong>20190122 <a href="https://mp.weixin.qq.com/s/FmK0RMCNNJe68Aq7tOUROA" target="_blank" rel="noopener">使用Flutter一年后，这是我得到的经验</a></strong></li><li><strong>20190123 <a href="https://medium.com/@antonmedv/discover-how-to-use-fx-effectively-668845d2a4ea" target="_blank" rel="noopener">Discover how to use fx effectively, a JSON manipulation command line tool</a></strong></li><li><strong>20190125 <a href="https://mp.weixin.qq.com/s/G-tA5xAgEsbyzswEI-_8Bg" target="_blank" rel="noopener">加载时间从4.6s降到0.7s，谷歌开源quicklink</a></strong></li></ul><h3 id="2019年第5周"><a href="#2019年第5周" class="headerlink" title="2019年第5周"></a>2019年第5周</h3><ul><li><strong>20190128 <a href="https://mp.weixin.qq.com/s/aybxmaiMMelz14F1GcWd1g" target="_blank" rel="noopener">2018年 JavaScript 明星项目</a></strong></li><li><strong>20190129 <a href="https://zhuanlan.zhihu.com/p/55357377" target="_blank" rel="noopener">给2019前端的5个建议</a></strong></li><li><strong>20190130 <a href="https://mp.weixin.qq.com/s/OzfhR5N7IQlmrDI-2LUcJQ" target="_blank" rel="noopener">Orinoco: V8的垃圾回收器</a></strong></li><li><strong>20190131 <a href="https://github.com/sorrycc/blog/issues/80" target="_blank" rel="noopener">Polyfill 方案的过去、现在和未来</a></strong></li></ul><h3 id="2019年第8周"><a href="#2019年第8周" class="headerlink" title="2019年第8周"></a>2019年第8周</h3><ul><li><strong>20190219 <a href="https://mp.weixin.qq.com/s/PX7b_qV6tYKnN3ecoz9Ehw" target="_blank" rel="noopener">独家！支付宝首次披露其小程序技术架构</a></strong></li></ul><p><img style="display:block;margin:auto;" src="https://img11.360buyimg.com/imagetools/s300x300_jfs/t1/26011/22/7362/61668/5c6bace4Ee80973ef/4b4f8f550b8b13db.jpg"></p>]]></content>
      
      
        <tags>
            
            <tag> share </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每日一文2018</title>
      <link href="/2019/12/19/dailyArtical2018/"/>
      <content type="html"><![CDATA[<h3 id="2018年第2周"><a href="#2018年第2周" class="headerlink" title="2018年第2周"></a>2018年第2周</h3><ul><li><strong>20180108 <a href="https://medium.com/dailyjs/the-most-popular-javascript-links-of-2017-e4616e8b48c7" target="_blank" rel="noopener">The most popular JavaScript links of 2017</a></strong></li><li><strong>20180109 <a href="https://www.smashingmagazine.com/2017/12/understanding-css-layout-block-formatting-context/" target="_blank" rel="noopener">Understanding CSS Layout And The Block Formatting Context</a></strong></li><li><strong>20180111 <a href="https://www.filamentgroup.com/lab/preload-ctm.html" target="_blank" rel="noopener">Can Preload Cut the Mustard?</a></strong><a id="more"></a></li></ul><h3 id="2018年第2周-1"><a href="#2018年第2周-1" class="headerlink" title="2018年第2周"></a>2018年第2周</h3><ul><li><strong>20180108 <a href="https://medium.com/dailyjs/the-most-popular-javascript-links-of-2017-e4616e8b48c7" target="_blank" rel="noopener">The most popular JavaScript links of 2017</a></strong></li><li><strong>20180109 <a href="https://www.smashingmagazine.com/2017/12/understanding-css-layout-block-formatting-context/" target="_blank" rel="noopener">Understanding CSS Layout And The Block Formatting Context</a></strong></li><li><strong>20180111 <a href="https://www.filamentgroup.com/lab/preload-ctm.html" target="_blank" rel="noopener">Can Preload Cut the Mustard?</a></strong></li></ul><h3 id="2018年第3周"><a href="#2018年第3周" class="headerlink" title="2018年第3周"></a>2018年第3周</h3><ul><li><strong>20180115 <a href="https://medium.freecodecamp.org/when-writing-code-is-a-waste-of-time-6602af8cb759" target="_blank" rel="noopener">When writing code is a waste of time.</a></strong></li><li><strong>20180117 <a href="https://medium.freecodecamp.org/all-you-need-to-know-about-parcel-dbe151b70082" target="_blank" rel="noopener">Everything You Need To Know About Parcel: The Blazing Fast Web App Bundler </a></strong></li><li><strong>20180118 <a href="https://medium.freecodecamp.org/10-points-to-remember-thatll-help-you-master-coding-in-reactjs-library-d0520d8c73d8" target="_blank" rel="noopener">How to write highly readable React code — 10 coding style tips</a></strong></li></ul><h3 id="2018年第4周"><a href="#2018年第4周" class="headerlink" title="2018年第4周"></a>2018年第4周</h3><ul><li><strong>20180122 <a href="https://dev.to/tylermcginnis/react-router-v4-philosophy-and-introduction-4ial" target="_blank" rel="noopener">React Router v4: Philosophy and Introduction</a></strong></li><li><strong>20180123 <a href="https://medium.freecodecamp.org/we-compiled-stats-for-the-top-javascript-projects-of-2017-heres-what-we-learned-441a1b77468c" target="_blank" rel="noopener">We Compiled Stats for the Top JavaScript Projects of 2017. Here’s What We Learned.</a></strong></li><li><strong>20180124 <a href="https://css-tricks.com/power-custom-directives-vue/" target="_blank" rel="noopener">The Power of Custom Directives in Vue</a></strong></li><li><strong>20180125 <a href="https://codeburst.io/javascript-can-a-1-a-2-a-3-ever-evaluate-to-true-aca13ff4462d" target="_blank" rel="noopener">JavaScript: Can (a==1 &amp;&amp; a==2 &amp;&amp; a==3) ever evaluate to true?</a></strong></li><li><strong>20180126 <a href="https://medium.freecodecamp.org/how-to-make-your-html-responsive-by-adding-a-single-line-of-css-2a62de81e431" target="_blank" rel="noopener">How to make your HTML responsive by adding a single line of CSS</a></strong></li></ul><h3 id="2018年第5周"><a href="#2018年第5周" class="headerlink" title="2018年第5周"></a>2018年第5周</h3><ul><li><strong>20180129 <a href="https://codeburst.io/cors-story-of-requesting-twice-85219da7172d" target="_blank" rel="noopener">CORS — Story of requesting twice</a></strong></li><li><strong>20180130 <a href="https://medium.freecodecamp.org/css-naming-conventions-that-will-save-you-hours-of-debugging-35cea737d849" target="_blank" rel="noopener">CSS Naming Conventions that Will Save You Hours of Debugging</a></strong></li><li><strong>20180131 <a href="https://nemethgergely.com/building-secure-javascript-applications/" target="_blank" rel="noopener">Building Secure JavaScript Applications</a></strong></li><li><strong>20180201 <a href="https://medium.com/webpack/webpack-4-beta-try-it-today-6b1d27d7d7e2" target="_blank" rel="noopener">webpack 4 beta — try it today!</a></strong></li><li><strong>20180202 <a href="https://dassur.ma/things/deep-copy/" target="_blank" rel="noopener">Deep-copying in JavaScript</a></strong></li></ul><h3 id="2018年第6周"><a href="#2018年第6周" class="headerlink" title="2018年第6周"></a>2018年第6周</h3><ul><li><strong>20180205 <a href="https://medium.com/dev-channel/why-progressive-web-apps-vs-native-is-the-wrong-question-to-ask-fb8555addcbb" target="_blank" rel="noopener">Why “Progressive Web Apps vs. native” is the wrong question to ask</a></strong></li><li><strong>20180208 <a href="https://codeburst.io/javascript-es6-the-spread-syntax-f5c35525f754" target="_blank" rel="noopener">JavaScript ES6— The Spread Syntax (…)</a></strong></li></ul><h3 id="2018年第9周"><a href="#2018年第9周" class="headerlink" title="2018年第9周"></a>2018年第9周</h3><ul><li><strong>20180227 <a href="https://www.smashingmagazine.com/2018/01/understanding-sizing-css-layout/" target="_blank" rel="noopener">How Big Is That Box? Understanding Sizing In CSS Layout</a></strong></li><li><strong>20180228 <a href="https://www.telerik.com/blogs/how-to-javascript-in-2018" target="_blank" rel="noopener">How to JavaScript in 2018</a></strong></li><li><strong>20180301 <a href="https://codeburst.io/javascript-map-vs-foreach-f38111822c0f" target="_blank" rel="noopener">JavaScript — Map vs. ForEach</a></strong></li><li><strong>20180302 <a href="https://medium.freecodecamp.org/code-splitting-with-react-and-react-router-62e174382d4c" target="_blank" rel="noopener">Code Splitting with React and React Router</a></strong></li></ul><h3 id="2018年第10周"><a href="#2018年第10周" class="headerlink" title="2018年第10周"></a>2018年第10周</h3><ul><li><strong>20180305 <a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">Render Props</a></strong></li><li><strong>20180306 <a href="https://dev.to/kepta/promising-promise-tips--c8f" target="_blank" rel="noopener">9 Promising Promise Tips</a></strong></li><li><strong>20180307 <a href="https://medium.com/dailyjs/7-hacks-for-es6-developers-4e24ff425d0b" target="_blank" rel="noopener">7 Hacks for ES6 Developers</a></strong></li><li><strong>20180309 <a href="https://medium.freecodecamp.org/typescript-javascript-with-super-powers-a333b0fcabc9" target="_blank" rel="noopener">TypeScript — JavaScript with superpowers</a></strong></li></ul><h3 id="2018年第11周"><a href="#2018年第11周" class="headerlink" title="2018年第11周"></a>2018年第11周</h3><ul><li><strong>20180312 <a href="https://medium.com/@paul_irish/requestanimationframe-scheduling-for-nerds-9c57f7438ef4" target="_blank" rel="noopener">requestAnimationFrame Scheduling For Nerds</a></strong></li><li><strong>20180313 <a href="https://medium.com/the-vue-point/whats-new-in-vue-devtools-4-0-9361e75e05d0" target="_blank" rel="noopener">What’s new in Vue Devtools 4.0</a></strong></li><li><strong>20180314 <a href="https://hackernoon.com/architecting-single-page-applications-b842ea633c2e" target="_blank" rel="noopener">The 4 Layers of Single Page Applications You Need to Know</a></strong></li><li><strong>20180315 <a href="https://medium.freecodecamp.org/learn-css-variables-in-5-minutes-80cf63b4025d" target="_blank" rel="noopener">Learn CSS Variables in 5 minutes</a></strong></li><li><strong>20180316 <a href="https://www.sitepoint.com/work-with-forms-in-react/" target="_blank" rel="noopener">React Quickly: How to Work with Forms in React</a></strong></li></ul><h3 id="2018年第12周"><a href="#2018年第12周" class="headerlink" title="2018年第12周"></a>2018年第12周</h3><ul><li><strong>20180319 <a href="https://www.codecamps.com/a-quick-guide-to-styled-components-with-interactive-examples/?utm_content=buffer9a2f1&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer" target="_blank" rel="noopener">A quick Guide to Styled Components with interactive Examples</a></strong></li><li><strong>20180320 <a href="https://medium.freecodecamp.org/check-out-these-useful-ecmascript-2015-es6-tips-and-tricks-6db105590377" target="_blank" rel="noopener">Check out these useful ECMAScript 2015 (ES6) tips and tricks</a></strong></li><li><strong>20180323 <a href="https://medium.com/@peedutuisk/lesser-known-css-quirks-oddities-and-advanced-tips-css-is-awesome-8ee3d16295bb" target="_blank" rel="noopener">Lesser known CSS quirks &amp; advanced tips</a></strong></li></ul><h3 id="2018年第13周"><a href="#2018年第13周" class="headerlink" title="2018年第13周"></a>2018年第13周</h3><ul><li><strong>20180326 <a href="https://codeburst.io/how-to-not-react-common-anti-patterns-and-gotchas-in-react-40141fe0dcd" target="_blank" rel="noopener">How to NOT React: Common Anti-Patterns and Gotchas in React</a></strong></li><li><strong>20180330 <a href="https://medium.freecodecamp.org/evolving-patterns-in-react-116140e5fe8f" target="_blank" rel="noopener">Evolving Patterns in React</a></strong></li></ul><h3 id="2018年第14周"><a href="#2018年第14周" class="headerlink" title="2018年第14周"></a>2018年第14周</h3><ul><li><strong>20180402 <a href="https://medium.freecodecamp.org/google-publishes-a-javascript-style-guide-here-are-some-key-lessons-1810b8ad050b" target="_blank" rel="noopener">13 Noteworthy Points from Google’s JavaScript Style Guide</a></strong></li></ul><h3 id="2018年第15周"><a href="#2018年第15周" class="headerlink" title="2018年第15周"></a>2018年第15周</h3><ul><li><strong>20180409 <a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">Update on Async Rendering</a></strong></li><li><strong>20180411 <a href="https://medium.freecodecamp.org/here-are-a-few-function-decorators-you-can-write-from-scratch-488549fe8f86" target="_blank" rel="noopener">Here are a few function decorators you can write from scratch</a></strong></li></ul><h3 id="2018年第16周"><a href="#2018年第16周" class="headerlink" title="2018年第16周"></a>2018年第16周</h3><ul><li><strong>20180416 <a href="https://www.loxodrome.io/post/cancelling-requests/" target="_blank" rel="noopener">Cancelling Requests with Abortable Fetch</a></strong></li><li><strong>20180417 <a href="https://medium.freecodecamp.org/here-are-examples-of-everything-new-in-ecmascript-2016-2017-and-2018-d52fa3b5a70e" target="_blank" rel="noopener">Here are examples of everything new in ECMAScript 2016, 2017, and 2018</a></strong></li><li><strong>20180418 <a href="https://medium.freecodecamp.org/typescript-javascript-with-super-powers-a333b0fcabc9" target="_blank" rel="noopener">TypeScript — JavaScript with superpowers</a></strong></li><li><strong>20180419 <a href="https://hackernoon.com/optimizing-a-static-site-d5ab6899f249" target="_blank" rel="noopener">10x Performance Increases: Optimizing a Static Site</a></strong></li></ul><h3 id="2018年第17周"><a href="#2018年第17周" class="headerlink" title="2018年第17周"></a>2018年第17周</h3><ul><li><strong>20180426 <a href="https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e" target="_blank" rel="noopener">A Simple Guide to ES6 Iterators in JavaScript with Examples</a></strong></li></ul><h3 id="2018年第19周"><a href="#2018年第19周" class="headerlink" title="2018年第19周"></a>2018年第19周</h3><ul><li><strong>20180507 <a href="https://levelup.gitconnected.com/whats-new-in-node-10-ad360ae55ee4?gi=a00877b2efef" target="_blank" rel="noopener">What’s New in Node 10</a></strong></li><li><strong>20180509 <a href="https://medium.freecodecamp.org/9-neat-javascript-tricks-e2742f2735c3" target="_blank" rel="noopener">Learn these neat JavaScript tricks in less than 5 minutes</a></strong></li></ul><h3 id="2018年第20周"><a href="#2018年第20周" class="headerlink" title="2018年第20周"></a>2018年第20周</h3><ul><li><strong>20180517 <a href="https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366" target="_blank" rel="noopener">webpack 4: Code Splitting, chunk graph and the splitChunks optimization</a></strong></li><li><strong>20180518 <a href="https://medium.com/@cramforce/designing-very-large-javascript-applications-6e013a3291a3" target="_blank" rel="noopener">Designing very large (JavaScript) applications</a></strong></li></ul><h3 id="2018年第21周"><a href="#2018年第21周" class="headerlink" title="2018年第21周"></a>2018年第21周</h3><ul><li><strong>20180522 <a href="https://engineering.hexacta.com/jsx-can-do-that-1b2666c23a32" target="_blank" rel="noopener">JSX can do that?</a></strong></li><li><strong>20180524 <a href="https://medium.freecodecamp.org/the-best-way-to-bind-event-handlers-in-react-282db2cf1530" target="_blank" rel="noopener">The best way to bind event handlers in React</a></strong></li></ul><h3 id="2018年第26周"><a href="#2018年第26周" class="headerlink" title="2018年第26周"></a>2018年第26周</h3><ul><li><strong>20180625 <a href="https://juejin.im/post/5b2236016fb9a00e9c47cb6b" target="_blank" rel="noopener">QQ音乐：React v16 新特性实践</a></strong></li><li><strong>20180626 <a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c" target="_blank" rel="noopener">React Native at Airbnb</a></strong></li><li><strong>20180628 <a href="https://medium.freecodecamp.org/how-you-can-improve-your-workflow-using-the-javascript-console-bdd7823a9472" target="_blank" rel="noopener">How you can improve your workflow using the JavaScript console</a></strong></li><li><strong>20180629 <a href="https://medium.com/styled-components/the-simple-guide-to-server-side-rendering-react-with-styled-components-d31c6b2b8fbf" target="_blank" rel="noopener">使用 styled-components 的 React 服务端渲染极简指南</a></strong></li></ul><h3 id="2018年第27周"><a href="#2018年第27周" class="headerlink" title="2018年第27周"></a>2018年第27周</h3><ul><li><strong>20180702 <a href="https://hackernoon.com/whats-revolutionary-about-flutter-946915b09514" target="_blank" rel="noopener">What’s Revolutionary about Flutter</a></strong></li><li><strong>20180704 <a href="https://zhuanlan.zhihu.com/p/36577285" target="_blank" rel="noopener">深入了解Flutter界面开发</a></strong></li><li><strong>20180705 <a href="https://zhuanlan.zhihu.com/p/38903385?utm_source=qq&amp;utm_medium=social&amp;utm_oi=78300059795456" target="_blank" rel="noopener">React转微信小程序：从React类定义到Component调用</a></strong></li><li><strong>20180706 <a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651008039&amp;idx=2&amp;sn=1e85cb23f98c8d58fa638471befa65ef&amp;chksm=bdbed4748ac95d621f1d9f55abff63c41cacac7555c6b17f4004d10c2fc3e9a9ba8748fa1b74&amp;mpshare=1&amp;scene=1&amp;srcid=0706ArXH35R1Hp0iUQxgzATi#rd" target="_blank" rel="noopener">百度新发布的智能小程序是什么？</a></strong></li></ul><h3 id="2018年第28周"><a href="#2018年第28周" class="headerlink" title="2018年第28周"></a>2018年第28周</h3><ul><li><strong>20180709 <a href="https://mp.weixin.qq.com/s/TSR4jIW_Zln2k-LaNvdwfQ" target="_blank" rel="noopener">如何构建一个理想UI代码表达的自动化工具？</a></strong></li><li><strong>20180710 <a href="https://mp.weixin.qq.com/s/q-4NzWJLimPSK9oaXOWUlA" target="_blank" rel="noopener">WebView缓存原理分析和应用</a></strong></li><li><strong>20180712 <a href="https://mp.weixin.qq.com/s/73Zg592gbykx8vWh3AGzyg" target="_blank" rel="noopener">JDReact小程序双向转换工具介绍</a></strong></li><li><strong>20180713 <a href="https://segmentfault.com/a/1190000015020658" target="_blank" rel="noopener">webpack实战</a></strong></li></ul><h3 id="2018年第29周"><a href="#2018年第29周" class="headerlink" title="2018年第29周"></a>2018年第29周</h3><ul><li><strong>20180716 <a href="https://juejin.im/post/5aa882eaf265da23923607bd" target="_blank" rel="noopener">由屎色自行车棚引发的思考</a></strong></li><li><strong>20180717 <a href="https://mp.weixin.qq.com/s/0ehjOhqkD3VHevVGU5-XOg" target="_blank" rel="noopener">组件开发的单元素模式</a></strong></li><li><strong>20180719 <a href="https://medium.com/@TechMagic/reactjs-vs-angular5-vs-vue-js-what-to-choose-in-2018-b91e028fa91d" target="_blank" rel="noopener">ReactJS vs Angular5 vs Vue.js — What to choose in 2018?</a></strong></li><li><strong>20180720 <a href="https://css-tricks.com/building-skeleton-screens-css-custom-properties/?utm_source=CSS-Weekly&amp;utm_campaign=Issue-281&amp;utm_medium=web" target="_blank" rel="noopener">Building Skeleton Screens with CSS Custom Properties</a></strong></li></ul><h3 id="2018年第30周"><a href="#2018年第30周" class="headerlink" title="2018年第30周"></a>2018年第30周</h3><ul><li><strong>20180723 <a href="https://zhuanlan.zhihu.com/p/40273861" target="_blank" rel="noopener">如何监控网页崩溃？service worker花式使用</a></strong></li><li><strong>20180724 <a href="https://medium.com/level-up-web/top-web-design-and-development-blogs-freebies-24be6a618041" target="_blank" rel="noopener">Top Web Design and Development Blogs + Freebies</a></strong></li><li><strong>20180727 <a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">通俗易懂的http两种缓存介绍</a></strong></li></ul><h3 id="2018年第31周"><a href="#2018年第31周" class="headerlink" title="2018年第31周"></a>2018年第31周</h3><ul><li><strong>20180730 <a href="https://daveceddia.com/context-api-vs-redux/" target="_blank" rel="noopener">Redux vs. The React Context API</a></strong></li><li><strong>20180803 <a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651554651&amp;idx=1&amp;sn=d25a1930c4be8ea33e7e133eec249063&amp;chksm=8025549ab752dd8c6a2fdbcd58cbba098b32631ead116072359746859459b5e1a127987ea8a9&amp;mpshare=1&amp;scene=1&amp;srcid=0803W9NBx3kWlCFHvLpJOkA8#rd" target="_blank" rel="noopener">Vue 和 React 区别的一些笔记</a></strong></li></ul><h3 id="2018年第32周"><a href="#2018年第32周" class="headerlink" title="2018年第32周"></a>2018年第32周</h3><ul><li><strong>20180808 <a href="http://www.tuicool.com/articles/I3imEvr" target="_blank" rel="noopener">深度对比 vue 和 react</a></strong></li></ul><h3 id="2018年第35周"><a href="#2018年第35周" class="headerlink" title="2018年第35周"></a>2018年第35周</h3><ul><li><strong>20180827 <a href="https://mp.weixin.qq.com/s/k68TStvjLAWwI7jZkA35Kw" target="_blank" rel="noopener">video 标签沉浸式播放解决方案</a></strong></li><li><strong>20180828 <a href="https://mp.weixin.qq.com/s/8mk7fo2PIo8JXIaZWtL7aQ" target="_blank" rel="noopener">CSS自定义属性</a></strong></li><li><strong>20180829 <a href="https://juejin.im/post/5b85e9f86fb9a01a175dc986" target="_blank" rel="noopener">Flutter和原生应用性能对比</a></strong></li><li><strong>20180830 <a href="https://juejin.im/post/5b7fb6f951882542ef0ee1c0" target="_blank" rel="noopener">一些 JavaScript 中的代码小技巧</a></strong></li></ul><h3 id="2018年第36周"><a href="#2018年第36周" class="headerlink" title="2018年第36周"></a>2018年第36周</h3><ul><li><strong>20180903 <a href="https://www.zhihu.com/question/30774735/answer/478049243" target="_blank" rel="noopener">怎样才是优秀的前端工程师</a></strong></li><li><strong>20180904 <a href="https://mp.weixin.qq.com/s/ue3gDfBR81E6uZ7ya7jBcQ" target="_blank" rel="noopener">React Fire：React DOM 的改造计划，使其更现代化</a></strong></li><li><strong>20180905 <a href="https://zhuanlan.zhihu.com/p/43257898" target="_blank" rel="noopener">小程序分享朋友圈-图片生成</a></strong></li><li><strong>20180906 <a href="https://medium.com/styled-components/announcing-styled-components-v4-better-faster-stronger-3fe1aba1a112" target="_blank" rel="noopener">announcing-styled-components-v4</a></strong></li><li><strong>20180907 <a href="https://medium.com/@foxhound87/automagically-manage-react-forms-state-with-mobx-and-automatic-validation-2b00a32b9769" target="_blank" rel="noopener">react表单状态管理方法介绍</a></strong></li></ul><h3 id="2018年第37周"><a href="#2018年第37周" class="headerlink" title="2018年第37周"></a>2018年第37周</h3><ul><li><strong>20180911 <a href="https://hackernoon.com/goodbye-redux-26e6a27b3a0b" target="_blank" rel="noopener">Goodbye Redux</a></strong></li></ul><h3 id="2018年第38周"><a href="#2018年第38周" class="headerlink" title="2018年第38周"></a>2018年第38周</h3><ul><li><strong>20180918 <a href="https://mp.weixin.qq.com/s/QI52VbaQfFOTZyNSfkHk0w" target="_blank" rel="noopener">选择JavaScript开源库时，你需要考虑这些问题</a></strong></li><li><strong>20180919 <a href="https://juejin.im/post/5b9e61b15188255c980bc6fd" target="_blank" rel="noopener">作为前端你拿什么证明网站体验？</a></strong></li><li><strong>20180920 <a href="https://juejin.im/post/5ba0bc8d6fb9a05d396f0827" target="_blank" rel="noopener">小程序的全栈开发新时代</a></strong></li><li><strong>20180921 <a href="https://mp.weixin.qq.com/s/pWpqgvy7Je79IiNWx_oMzQ" target="_blank" rel="noopener">JavaScript 2018 中即将迎来的新功能</a></strong></li><li><strong>20180922 <a href="https://juejin.im/post/5ba1f995f265da0a972e1657" target="_blank" rel="noopener">React性能分析利器来了，妈妈再也不用担心我的React应用慢了</a></strong></li></ul><h3 id="2018年第39周"><a href="#2018年第39周" class="headerlink" title="2018年第39周"></a>2018年第39周</h3><ul><li><strong>20180926 <a href="https://mp.weixin.qq.com/s/9vdGB0h4aZgwBgr-7TwFXQ" target="_blank" rel="noopener">微信小程序跨页面通信解决思路</a></strong></li></ul><h3 id="2018年第41周"><a href="#2018年第41周" class="headerlink" title="2018年第41周"></a>2018年第41周</h3><ul><li><strong>20181011 <a href="https://zhuanlan.zhihu.com/p/46280019" target="_blank" rel="noopener">React大会 &amp;&amp; FEDAY 演讲视频来啦，持续更新中…</a></strong></li></ul><h3 id="2018年第42周"><a href="#2018年第42周" class="headerlink" title="2018年第42周"></a>2018年第42周</h3><ul><li><strong>20181015 <a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651230032&amp;idx=1&amp;sn=29adcf0c2a314d6c931e96efd9e193d8&amp;chksm=bd4956d48a3edfc2b8adeb1b0cf66c9ac725b2985c388b530ba56127a1e720c937c5170ac0d1&amp;mpshare=1&amp;scene=23&amp;srcid=10152MRBJJla9PPtcM6MQX2L#rd" target="_blank" rel="noopener">Airbnb 爱彼迎房源详情页中的 React 性能优化</a></strong></li><li><strong>20181016 <a href="https://mp.weixin.qq.com/s/WXfTjb3w51yvM3U50Y_AEg" target="_blank" rel="noopener">浅析 React / Vue 跨端渲染原理与实现</a></strong></li><li><strong>20181017 <a href="https://juejin.im/post/5b7a8dc2e51d4538b81efff6" target="_blank" rel="noopener">2018年最值得关注学习的25个JavaScript开源项目</a></strong></li><li><strong>20181018 <a href="https://mp.weixin.qq.com/s/8vAJs6cXoSsj6gyRCqznYg" target="_blank" rel="noopener">30 分钟理解 CORB 是什么</a></strong></li><li><strong>20181019 <a href="https://medium.freecodecamp.org/image-optimization-558d9f449e3" target="_blank" rel="noopener">How Image Optimization Decreased my Website’s Page Weight by 62%</a></strong></li></ul><h3 id="2018年第43周"><a href="#2018年第43周" class="headerlink" title="2018年第43周"></a>2018年第43周</h3><ul><li><strong>20181022 <a href="https://juejin.im/post/5bc1ae9be51d450e8b140b0c" target="_blank" rel="noopener">深拷贝的终极探索（90%的人都不知道</a></strong></li><li><strong>20181023 <a href="https://mp.weixin.qq.com/s/KmaJYYutkWQxXqeiYhnCWw" target="_blank" rel="noopener">如何做一个听话的 “输入框”</a></strong></li><li><strong>20181024 <a href="https://www.zhihu.com/question/299741613" target="_blank" rel="noopener">未来十年哪些基础科学突破会影响互联网科技产业？</a></strong></li><li><strong>20181025 <a href="https://mp.weixin.qq.com/s/L6JHBlKsTpkTMREZWUWQ8Q" target="_blank" rel="noopener">你听说过原生 HTML 组件吗？</a></strong></li><li><strong>20181026 <a href="https://9elements.com/io/css-border-radius/?utm_source=Responsive+Design+Weekly&amp;utm_campaign=bfbab21359-RWD_Newsletter_331&amp;utm_medium=email&amp;utm_term=0_df65b6d7c8-bfbab21359-59155205&amp;mc_cid=bfbab21359&amp;mc_eid=f02684dce6" target="_blank" rel="noopener">CSS BORDER-RADIUS CAN DO THAT?</a></strong></li></ul><h3 id="2018年第44周"><a href="#2018年第44周" class="headerlink" title="2018年第44周"></a>2018年第44周</h3><ul><li><strong>20181029 <a href="https://mp.weixin.qq.com/s/AulQz3BWQgWHlnK7LUXLbg" target="_blank" rel="noopener">React v16.7 “Hooks” - What to Expect</a></strong></li><li><strong>20181030 <a href="https://mp.weixin.qq.com/s/cb8VJOmAB1Yrv-ct4jJ3JQ" target="_blank" rel="noopener">图解浏览器的基本工作原理</a></strong></li></ul><h3 id="2018年第45周"><a href="#2018年第45周" class="headerlink" title="2018年第45周"></a>2018年第45周</h3><ul><li><strong>20181106 <a href="https://juejin.im/post/5bdd67206fb9a04a0c2de0c3" target="_blank" rel="noopener">使用HTML5 IndexDB存储图像和文件</a></strong></li><li><strong>20181107 <a href="https://juejin.im/entry/5be2243451882516c713cda4" target="_blank" rel="noopener">ES2018（ES9） 带来的重大新特性 – JavaScript 完全手册（2018版）</a></strong></li><li><strong>20181108 <a href="https://juejin.im/post/5be25553f265da611b57d2ee" target="_blank" rel="noopener">你所知道或不知道的CSS content属性</a></strong></li><li><strong>20181109 <a href="https://zhuanlan.zhihu.com/p/47396514" target="_blank" rel="noopener">【译文】构建大型 Redux 应用的五个建议</a></strong></li></ul><h3 id="2018年第46周"><a href="#2018年第46周" class="headerlink" title="2018年第46周"></a>2018年第46周</h3><ul><li><strong>20181112 <a href="https://mp.weixin.qq.com/s/BXC6tZyY6fsi8l8dJ40nug" target="_blank" rel="noopener">React 中同构（SSR）原理脉络梳理</a></strong></li><li><strong>20181113 <a href="https://juejin.im/post/5be84b54e51d4540697f2b67" target="_blank" rel="noopener">漫话：如何给女朋友解释为什么双11无法修改收货地址</a></strong></li><li><strong>20181114 <a href="https://juejin.im/post/5bea9bb26fb9a049e4123e60" target="_blank" rel="noopener">你所不知道的 CSS 阴影技巧与细节</a></strong></li><li><strong>20181115 <a href="https://mp.weixin.qq.com/s/hOKfbgd-nRn2lboXMCiY8w" target="_blank" rel="noopener">前后端均适用的网络知识点大全</a></strong></li><li><strong>20181116 <a href="https://segmentfault.com/a/1190000016759517" target="_blank" rel="noopener">h5 与原生 app 交互的原理</a></strong></li></ul><h3 id="2018年第47周"><a href="#2018年第47周" class="headerlink" title="2018年第47周"></a>2018年第47周</h3><ul><li><strong>20181119 <a href="https://juejin.im/post/5bee7dd4e51d451f5b54cbb4" target="_blank" rel="noopener">前端黑科技：美团网页首帧优化实践</a></strong></li><li><strong>20181120 <a href="https://mp.weixin.qq.com/s/uc6ZQx0KRZfqJoT_VzUyFg" target="_blank" rel="noopener">见微知著，Google Photos Web UI 完善之旅</a></strong></li><li><strong>20181121 <a href="https://medium.com/@dimaiv/animating-complex-svg-in-react-c555630f15cd" target="_blank" rel="noopener">Animating complex SVG in React</a></strong></li><li><strong>20181122 <a href="https://mp.weixin.qq.com/s/xWzZbW4bplG81Ao8oGNC3Q" target="_blank" rel="noopener">淘宝首页2018：回归初心，化繁为简</a></strong></li><li><strong>20181123 <a href="https://www.jianshu.com/p/58df9fba7049" target="_blank" rel="noopener">函数式思维</a></strong></li></ul><h3 id="2018年第48周"><a href="#2018年第48周" class="headerlink" title="2018年第48周"></a>2018年第48周</h3><ul><li><strong>20181126 <a href="https://mp.weixin.qq.com/s/gwjV0NC8JbF-QfwuQ-ayjw" target="_blank" rel="noopener">CSS 与网络性能</a></strong></li><li><strong>20181127 <a href="https://mp.weixin.qq.com/s/-yNglTnJFbaDDFbq9usleA" target="_blank" rel="noopener">await VS return VS return await</a></strong></li><li><strong>20181128 <a href="https://http3-explained.haxx.se/en/" target="_blank" rel="noopener">HTTP3</a></strong></li><li><strong>20181129 <a href="https://mp.weixin.qq.com/s/ciyc9z8ZaVwSpriQoUCHHA" target="_blank" rel="noopener">深度掌握webpack的5个关键点</a></strong></li><li><strong>20181130 <a href="https://nice.lovejade.cn/zh/article/develop-quick-app-experience-notes.html" target="_blank" rel="noopener">快应用之开发体验纪要</a></strong></li></ul><h3 id="2018年第49周"><a href="#2018年第49周" class="headerlink" title="2018年第49周"></a>2018年第49周</h3><ul><li><strong>20181203 <a href="https://mp.weixin.qq.com/s/JruxINKKYAlzcsTM6c5eyA" target="_blank" rel="noopener">JS常用各种正则表达式（汇总）</a></strong></li><li><strong>20181204 <a href="https://mp.weixin.qq.com/s/3EKCh9g-yvdMcT_r1gFexA" target="_blank" rel="noopener">Web前端三驾马车现状如何？2018 JavaScript 现状调查报告火热出炉！</a></strong></li><li><strong>20181205 <a href="https://www.tslang.cn/docs/release-notes/typescript-3.1.html" target="_blank" rel="noopener">typescript 3.1 ~</a></strong></li><li><strong>20181206 <a href="https://mp.weixin.qq.com/s/pBR6VVflkBAgRCDJrVi5iA" target="_blank" rel="noopener">前端构建：3 类 13 种热门工具的选型参考</a></strong></li><li><strong>20181207 <a href="https://zhuanlan.zhihu.com/p/51118741" target="_blank" rel="noopener">谨慎处理 Service Worker 的更新</a></strong></li></ul><h3 id="2018年第50周"><a href="#2018年第50周" class="headerlink" title="2018年第50周"></a>2018年第50周</h3><ul><li><strong>20181210 <a href="https://juejin.im/post/5c088c4ce51d451d8b7bd8de" target="_blank" rel="noopener">[译] React 是如何区分 Class 和 Function 的 ?</a></strong></li><li><strong>20181211 <a href="https://mp.weixin.qq.com/s/2fnJADWMneTg6Zxl_oVahA" target="_blank" rel="noopener">8 张图帮你一步步看清 async/await 和 promise 的执行顺序</a></strong></li><li><strong>20181212 <a href="https://juejin.im/post/5c0db59f6fb9a049bb7c2810" target="_blank" rel="noopener">flutter 视频课程</a></strong></li><li><strong>20181213 <a href="https://juejin.im/post/5c10fc4de51d455bea33a5e4" target="_blank" rel="noopener">JS HTTP 请求库哪家强？Axios，Request，Superagent，Fetch 还是 Supertest</a></strong></li><li><strong>20181214 <a href="https://mp.weixin.qq.com/s/PP0iUN9zQdOwincMyAoseQ" target="_blank" rel="noopener">2018年浏览器混战：为什么技术救不了Edge？</a></strong></li></ul><h3 id="2018年第51周"><a href="#2018年第51周" class="headerlink" title="2018年第51周"></a>2018年第51周</h3><ul><li><strong>20181217 <a href="https://segmentfault.com/a/1190000017365632" target="_blank" rel="noopener">JS 中经常使用的小技巧，助你更简短的实现一些功能</a></strong></li><li><strong>20181218 <a href="https://mp.weixin.qq.com/s/cO2FUFnQo44HXdSGxbb-SQ" target="_blank" rel="noopener">别骗自己了，你不用TypeScript的理由站不住脚</a></strong></li><li><strong>20181219 <a href="https://juejin.im/entry/5c16f590e51d45065e616046?utm_source=gold_browser_extension" target="_blank" rel="noopener">前端开发 2018 回顾及 2019 展望</a></strong></li><li><strong>20181220 <a href="https://juejin.im/post/5c19c5e0e51d4502a232c1c6" target="_blank" rel="noopener">一口(很长的)气了解 babel</a></strong></li><li><strong>20181221 <a href="https://www.yuque.com/es2049/blog/al62bl" target="_blank" rel="noopener">想写好前端，先练好内功</a></strong></li></ul><h3 id="2018年第52周"><a href="#2018年第52周" class="headerlink" title="2018年第52周"></a>2018年第52周</h3><ul><li><strong>20181224 <a href="https://juejin.im/post/5c09a80151882521c81168a2" target="_blank" rel="noopener">devtools tips 合集</a></strong></li><li><strong>20181225 <a href="https://mp.weixin.qq.com/s/wRBMDqhgTfcOkT4eDAihjg" target="_blank" rel="noopener">我经历过 webpack 1、2、3、4 变迁后，深度拆解了webpack</a></strong></li><li><strong>20181226 <a href="https://juejin.im/post/5c21b584e51d4548ac6f6c99" target="_blank" rel="noopener">深入Babel，这一篇就够了</a></strong></li><li><strong>20181227 <a href="https://juejin.im/post/5c2042e95188255e9b620964" target="_blank" rel="noopener">如何在 ES5 环境下实现一个const ？</a></strong></li></ul><p><img style="display:block;margin:auto;" src="https://img11.360buyimg.com/imagetools/s300x300_jfs/t1/26011/22/7362/61668/5c6bace4Ee80973ef/4b4f8f550b8b13db.jpg"></p>]]></content>
      
      
        <tags>
            
            <tag> share </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端开发工具整理</title>
      <link href="/2019/12/19/fe-tools/"/>
      <content type="html"><![CDATA[<p>前端开发工具简单整理，包括Chrome Extension和VS Code Extensions</p><a id="more"></a><p>在科技界，有成千上万的工具供人们使用。你怎么知道从哪里开始呢?</p><p>对于最近刚开始编程的人一样，这种大量的信息太过肤浅。我发现自己安装的扩展在我的开发周期中并没有真正帮助到我，甚至常常妨碍我的开发。</p><p>我绝不是专家。但是，随着时间的推移，我编制了一份工具清单，这些工具已经被证明对我非常有用。如果你刚刚开始学习如何编程，这将给你提供一些指导。如果你是一个经验丰富的开发人员，希望你还能学到一些新的东西。</p><p>我将把这篇文章分为Chrome扩展和VS代码扩展。我知道还有其他浏览器和文本编辑器，但我敢打赌，大多数工具也可以用于您的选择平台。所以，我们不要因为个人喜好而引发一场信仰上的争论。</p><h2 id="Chrome-Extensions"><a href="#Chrome-Extensions" class="headerlink" title="Chrome Extensions"></a>Chrome Extensions</h2><p>现在我是一个自称的web开发人员。我实际上生活在我的Chrome控制台中。下面是一些能让我少花点时间在那里的工具。</p><ul><li><p>WhatFont[1] 名字就说明了一切。这是找到你最喜欢的网站使用的字体的简单方法。这样你就可以把它们借给你自己的项目了。</p></li><li><p>Pesticide  用于查看div标签的轮廓以及修改CSS。当我试着在盒子模型周围学习的时候，这是一个救命稻草。</p></li><li><p>Colorzilla 对复制网站上的精确颜色很有用。该工具可以将颜色直接复制到剪贴板上，这样你就不会花太多时间去获取正确的RGBA组合了。</p></li><li><p>CSS Peeper 用于查看网站上使用的颜色和资源。特别是刚开始的时候，一个好的锻炼就是克隆你认为酷的网站。这让您可以查看他们的颜色方案的幕后，并允许您查看在其页面上的其它资源。</p></li><li><p>Wappalyzer 用于查看在网站上使用的技术。想知道一个网站正在使用什么样的框架，或者它承载了什么样的服务。看一看该工具吧。</p></li><li><p>React Dev Tools 有助于调试您的React应用程序。值得一提的是，只有在您编写一个React应用程序时，这才有用。</p></li><li><p>Redux Dev Tools 用于调试使用了Redux的应用程序。值得一提的是，只有在应用程序中实现Redux时，这才有用。</p></li><li><p>JSON Formatter 在浏览器中使JSON看起来更简洁是很有用的。你是否曾经盯着一个丑陋的JSON？试图弄清楚你想要的信息有多深？使用该工具只需要2个小时而不是3个小时。</p></li><li><p>Vimeo Repeat and Speed 用于加速Vimeo视频。如果你像大多数web开发人员一样观看视频教程。你知道用1.25倍的常规播放速度来观看它们是多么方便。当然也有YouTube的版本。</p></li></ul><h2 id="VS-Code-Extensions"><a href="#VS-Code-Extensions" class="headerlink" title="VS Code Extensions"></a>VS Code Extensions</h2><p>Visual Studio Code是我的编辑器。</p><p>人们喜欢他们的文本编辑器，我也不例外。不过，我打赌这些扩展中的大部分都可以用于您所使用的任何编辑器。看看我最喜欢的扩展。</p><ul><li><p>Auto Rename Tag 自动重命名成对的HTML标记。您创建了一个</p><p>标记。现在，您想要更改它，以及它的闭合</p>标记。只要改变一个，另一个就会跟随着变化。理论上可以提高你的工作效率2倍。<p></p></li><li><p>HTML CSS Support CSS对HTML文档的支持。这对于获得一些简洁的语法高亮显示和代码建议非常有用，这样CSS只会让你每天都想放弃几次代码。</p></li><li><p>HTML Snippets 它是有用的代码片段，另外也是一个很好的节省时间的工具。与Emmet配对，你几乎不用再键入真正的HTML。</p></li><li><p>Babel ES6/ES7 添加JavaScript Babel语法颜色。如果您使用的是Babel，这将使您更容易区分代码中正在发生的事情。如果您喜欢使用JavaScript的现代特性，这是很优雅的。</p></li><li><p>Bracket Pair Colorizer 将颜色添加到方括号中，以方便块可视化。这对于那些非常常见的错误非常方便，比如您没有准确地关闭括号或圆括号。</p></li><li><p>ESLint 将ESLint集成到Visual Studio代码中。当您编写代码时，这可以方便地获得有关bug的提示，而且根据您的配置，它可以帮助强制执行良好的编码风格。</p></li><li><p>Guides 为代码添加额外的引导行。这是另一个视觉提示，以确保您正确地关闭了括号。</p></li><li><p>JavaScript Console Utils 使得查看控制台日志更加容易。如果您像大多数开发人员一样，您将发现自己在调试流程中打印到控制台(我知道我们应该使用调试器)。这个实用程序使得创建有用的console.log()语句变得很容易。</p></li><li><p>Code Spell Checker 描述驼峰拼写法的检查程序。另一个常见的错误来源是按错键书写的变量或函数名。这个拼写检查器将查找不常见的单词，并且很好地解释了我们用JavaScript编写东西的方式。</p></li><li><p>Git Lens 让人更容易看清何时，以及由谁做出的改变。当代码被破坏时，这很好地归咎到正确的人，因为这绝对不是你的错。</p></li><li><p>Path Intellisense 文件路径自动完成。这对于从其他文件导入东西非常方便。它使你的文件树导航变得轻而易举。</p></li><li><p>Prettier 自动代码格式化。忘掉那些你不得不手动缩进代码的日子，让一切变得清晰可认吧。</p></li><li><p>VSCode-Icons 向文件树添加图标。如果看你的文件结构伤害了你的眼睛，这可能会有帮助。对于你正在制作的任何文件，都有一个有用的图标，这将使你更容易区分你所看到的内容。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>您可能有自己的一套工具，这些工具在您的开发周期中是必不可少的。希望我上面提到的一些工具能够提高您的工作效率。<br>但是，不要落入陷阱。因为，在学习使用已经拥有的工具之前，要安装所有的工具，这可能是一个巨大的时间消耗。<br>我鼓励您在下面的评论中留下您最喜欢的工具，这样我们就可以一起学习了。</p><p><strong>参考链接：</strong></p><p>Chrome Extensions</p><ul><li><a href="https://chrome.google.com/webstore/detail/whatfont/jabopobgcpjmedljpbcaablpmlmfcogm?hl=en" target="_blank" rel="noopener">WhatFont</a></li><li><a href="https://chrome.google.com/webstore/detail/pesticide-for-chrome/bblbgcheenepgnnajgfpiicnbbdmmooh?hl=en" target="_blank" rel="noopener">Pesticide</a></li><li><a href="https://chrome.google.com/webstore/detail/colorzilla/bhlhnicpbhignbdhedgjhgdocnmhomnp?hl=en" target="_blank" rel="noopener">Colorzilla</a></li><li><a href="https://chrome.google.com/webstore/detail/css-peeper/mbnbehikldjhnfehhnaidhjhoofhpehk?hl=en" target="_blank" rel="noopener">CSS Peeper</a></li><li><a href="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?hl=en" target="_blank" rel="noopener">Wappalyzer</a></li><li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" target="_blank" rel="noopener">React Dev Tools</a></li><li><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en" target="_blank" rel="noopener">Redux Dev Tools</a></li><li><a href="https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=en" target="_blank" rel="noopener">JSON Formatter</a></li><li><a href="https://chrome.google.com/webstore/detail/vimeo-repeat-speed/noonakfaafcdaagngpjehilgegefdima?hl=en" target="_blank" rel="noopener">Vimeo Repeat and Speed</a></li></ul><p>VS Code Extensions</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener">Auto Rename Tag</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=ecmel.vscode-html-css" target="_blank" rel="noopener">HTML CSS Support</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=abusaidm.html-snippets" target="_blank" rel="noopener">HTML Snippets</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=dzannotti.vscode-babel-coloring" target="_blank" rel="noopener">Babel ES6/ES7</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer" target="_blank" rel="noopener">Bracket Pair Colorizer</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=spywhere.guides" target="_blank" rel="noopener">Guides</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=whtouche.vscode-js-console-utils" target="_blank" rel="noopener">JavaScript Console Utils</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker" target="_blank" rel="noopener">Code Spell Checker</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" target="_blank" rel="noopener">Git Lens</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" target="_blank" rel="noopener">Path Intellisense</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons" target="_blank" rel="noopener">VSCode-Icons</a></li></ul><p><img style="display:block;margin:auto;" src="https://img11.360buyimg.com/imagetools/s300x300_jfs/t1/26011/22/7362/61668/5c6bace4Ee80973ef/4b4f8f550b8b13db.jpg"></p>]]></content>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack 5 changelog</title>
      <link href="/2019/12/19/webpack5-changelog/"/>
      <content type="html"><![CDATA[<p>webpack5的changelog翻译</p><a id="more"></a><p>原文链接：<a href="https://github.com/webpack/changelog-v5" target="_blank" rel="noopener">webpack-changelog-v5</a></p><h2 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h2><p>v5重点：</p><ul><li>尝试使用持久性缓存来提高构建性能。</li><li>尝试使用更好的算法和默认值来改进长期缓存</li><li>尝试在不进行重大更新的情况下，清理在v4中实现特性时处于怪异状态的内部结构。</li><li>尝试通过重大更新来尽可能长时间地停留在v5上，从而为将来的特性做准备。</li></ul><h2 id="主要更新"><a href="#主要更新" class="headerlink" title="主要更新"></a>主要更新</h2><h3 id="删除了弃用的东西"><a href="#删除了弃用的东西" class="headerlink" title="删除了弃用的东西"></a>删除了弃用的东西</h3><p>v4中已弃用的所有内容都已删除。<br>迁移：确保你的webpack 4版本不打印弃用警告。<br>以下是一些已删除但在v4中没有弃用警告的内容：</p><ul><li>IgnorePlugin和BannerPlugin必须传递一个options对象。</li></ul><h3 id="删除自动添加的nodejs-polyfills"><a href="#删除自动添加的nodejs-polyfills" class="headerlink" title="删除自动添加的nodejs  polyfills"></a>删除自动添加的nodejs  polyfills</h3><p>在早期，webpack旨在允许在浏览器中运行大多数node.js模块，但模块格局发生了变化，许多模块现在都是为了前端而编写的。<br>webpack &lt;= 4 附带了许多node.js核心模块的polyfill。一旦使用就会自动添加。<br>虽然这使得使用为node.js编写的模块变得简单，但这会将巨大的polyfill添加到bundle中。在许多情况下，我们甚至并不需要这些polyfills。<br>webpack 5停止自动填充这些核心模块，并试图专注于前端兼容的模块。</p><p>迁移：</p><ul><li>尽可能尝试使用前端兼容模块</li><li>可以手动为node.js核心模块添加polyfill。错误消息会告诉你如何执行此操作</li><li>package作者：使用package.json中的browser字段让package做到前端兼容。为浏览器提供可替代的implementations/dependencies</li></ul><p>反馈：请提供您喜欢或不喜欢这种变化的反馈。我们不确定这是否会进入最终版本。</p><h3 id="确定的Chunk以及模块ids"><a href="#确定的Chunk以及模块ids" class="headerlink" title="确定的Chunk以及模块ids"></a>确定的Chunk以及模块ids</h3><p>我们为长期缓存添加了新算法。这些在生产模式下默认启用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunkIds: &quot;deterministic&quot;, moduleIds: &quot;deterministic&quot;</span><br></pre></td></tr></table></figure><p>算法为module和chunk分配3或4个字符数字id。这是bundle size和长期缓存之间的权衡。<br>迁移：<br>最好使用chunkIds和moduleIds的默认值。您也可以选择使用旧的默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunkIds: &quot;size&quot;, moduleIds: &quot;size&quot;</span><br></pre></td></tr></table></figure></p><p>这将创建更小的bundles</p><h3 id="命名块ids"><a href="#命名块ids" class="headerlink" title="命名块ids"></a>命名块ids</h3><p>在开发模式下默认启用的新命名块ID算法为块（和文件名）提供了有用的名称。模块ID由路径确定。块ID由块内容确定。<br>所以你不再需要使用以下代码来debug<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(/* webpackChunkName: &quot;name&quot; */ &quot;module&quot;)</span><br></pre></td></tr></table></figure></p><p>但是这仍然使得控制生产的文件名有意义。<br>在生产环境可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunkIds: &quot;named&quot;</span><br></pre></td></tr></table></figure></p><p>但要确保不要意外地暴露有关模块名称的敏感信息。<br>迁移：<br>如果在开发模式下，你不喜欢更改文件名，你可以设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunkIds: &quot;natural&quot;</span><br></pre></td></tr></table></figure><h3 id="编译器空闲和关闭"><a href="#编译器空闲和关闭" class="headerlink" title="编译器空闲和关闭"></a>编译器空闲和关闭</h3><p>编译器现在需要在使用后关闭。编译器在进入和离开空闲状态时都提供了钩子函数。插件可以使用它来做不重要的工作。即持久缓存缓慢地存储缓存到硬盘。<br>插件认为某些用户可能忘记关闭编译器，因此所有工作最终都应该在空闲状态下完成。当工作完成时，应该防止进程退出。传递回调时，webpack（）会自动调用close。<br>迁移：<br>使用node.js API时，请确保在完成后调用Compiler.close。</p><h3 id="SplitChunks和模块大小"><a href="#SplitChunks和模块大小" class="headerlink" title="SplitChunks和模块大小"></a>SplitChunks和模块大小</h3><p>相比单个数字，模块现在以更好的方式来表示大小。现在有不同类型的大小。<br>SplitChunksPlugin学习了如何处理这些不同的大小并将它们用于minSize和maxSize。默认情况下，只处理javascript大小。但现在可以传递多个值来处理它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minSize: &#123;</span><br><span class="line">  javascript: 30000,</span><br><span class="line">  style: 50000,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迁移：<br>检查你在构建过程中使用哪种大小类型并且在splitChunks.minSize或splitChunks.maxSize中配置。</p><h3 id="持久缓存"><a href="#持久缓存" class="headerlink" title="持久缓存"></a>持久缓存</h3><p>现在有一个实验性的文件系统缓存。这是可选的，可以通过在配置中设置来生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache: &#123; type: &quot;filesystem&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>目前只有核心功能集已准备就绪，在使用它时，应该了解当前的限制以避免奇怪的错误。如果不理解这些限制，就不要使用此功能。</p><p>模块源代码和文件系统结构存在自动缓存失效。配置和loader/插件/核心更改没有自动缓存失效。配置或构建代码更改时，可以选择手动缓存失效 (cache.version)。</p><p>我们计划添加这个，但是还没有准备好。</p><p>下面是一个指南：</p><ul><li>升级工具依赖项（webpack，loader，plugin）</li><li>改变配置</li></ul><p>提示：如果想要自动执行此操作，最好将webpack.config.js和node_modules / .yarn-integrity哈希化，并将其传递给cache.version。我们可能会这样来做。</p><h3 id="最小的nodejs版本"><a href="#最小的nodejs版本" class="headerlink" title="最小的nodejs版本"></a>最小的nodejs版本</h3><p>最小的node.js版本从6增加到8。<br>迁移：<br>升级到最新的node.js版本</p><h2 id="配置的更改"><a href="#配置的更改" class="headerlink" title="配置的更改"></a>配置的更改</h2><p>结构的变化：</p><ul><li><code>cache: Object</code> removed: Setting to a memory-cache object is no longer possible</li><li><code>cache.type</code> added: It’s now possible to choose between <code>&quot;memory&quot;</code> and <code>&quot;filesystem&quot;</code></li><li>New configuration options for <code>cache.type = &quot;filesystem&quot;</code> added:<ul><li><code>cache.cacheDirectory</code></li><li><code>cache.name</code></li><li><code>cache.version</code></li><li><code>cache.store</code></li><li><code>cache.loglevel</code></li><li><code>cache.hashAlgorithm</code></li></ul></li><li><code>resolve.cache</code> added: Allows to disable/enable the safe resolve cache</li><li><code>resolve.concord</code> removed</li><li>Automatic polyfills for native node.js modules were removed<ul><li><code>node.Buffer</code> removed</li><li><code>node.console</code> removed</li><li><code>node.process</code> removed</li><li><code>node.*</code> (node.js native module) removed</li><li>MIGRATION: <code>resolve.alias</code> and <code>ProvidePlugin</code>. Errors will give hints.</li></ul></li><li><code>optimization.chunkIds: &quot;deterministic&quot;</code> added</li><li><code>optimization.moduleIds: &quot;deterministic&quot;</code> added</li><li><code>optimization.moduleIds: &quot;hashed&quot;</code> deprecated</li><li><code>optimization.moduleIds: &quot;total-size&quot;</code> removed</li><li>Deprecated flags for module and chunk ids were removed<ul><li><code>optimization.hashedModuleIds</code> removed</li><li><code>optimization.namedChunks</code> removed (<code>NamedChunksPlugin</code> too)</li><li><code>optimization.namedModules</code> removed (<code>NamedModulesPlugin</code> too)</li><li><code>optimization.occurrenceOrder</code> removed</li><li>MIGRATION: Use <code>chunkIds</code> and <code>moduleIds</code></li></ul></li><li><code>optimization.splitChunks</code> sizes can now be objects with a size per source type<ul><li><code>minSize</code></li><li><code>maxSize</code></li><li><code>maxAsyncSize</code></li><li><code>maxInitialSize</code></li></ul></li><li><code>optimization.splitChunks</code> <code>maxAsyncSize</code> and <code>maxInitialSize</code> added next to <code>maxSize</code>: allows to specify different max sizes for initial and async chunks</li><li><code>optimization.splitChunks</code> <code>name: true</code> removed: Automatic names are no longer supported<ul><li>MIGRATION: Use the default. <code>chunkIds: &quot;named&quot;</code> will give your files useful names for debugging</li></ul></li><li><code>optimization.splitChunks.cacheGroups[].idHint</code> added: Gives a hint how the named chunk id should be chosen</li><li><code>optimization.splitChunks</code> <code>automaticNamePrefix</code> removed<ul><li>MIGRATION: Use <code>idHint</code> instead</li></ul></li><li><code>output.devtoolLineToLine</code> removed<ul><li>MIGRATION: No replacement</li></ul></li><li><code>output.hotUpdateChunkFilename: Function</code> is now forbidden: It never worked anyway.</li><li><code>output.hotUpdateMainFilename: Function</code> is now forbidden: It never worked anyway.</li><li><code>stats.chunkRootModules</code> added: Show root modules for chunks</li><li><code>stats.orphanModules</code> added: Show modules which are not emitted</li><li><code>stats.runtime</code> added: Show runtime modules</li><li><code>stats.chunkRelations</code> added: Show parent/children/sibling chunks (since alpha.1)</li><li><code>stats.preset</code> added: select a preset (since alpha.1)</li><li><code>BannerPlugin.banner</code> signature changed<ul><li><code>data.basename</code> removed</li><li><code>data.query</code> removed</li><li>MIGRATION: extract from <code>filename</code></li></ul></li><li><code>SourceMapDevToolPlugin</code> <code>lineToLine</code> removed<ul><li>MIGRATION: No replacement</li></ul></li><li><code>[hash]</code> as hash for the full compilation is now deprecated<ul><li>MIGRATION: Use <code>[fullhash]</code> instead or better use another hash option</li></ul></li><li><code>[modulehash]</code> is deprecated<ul><li>MIGRATION: Use <code>[hash]</code> instead</li></ul></li><li><code>[moduleid]</code> is deprecated<ul><li>MIGRATION: Use <code>[id]</code> instead</li></ul></li><li><code>[filebase]</code> removed<ul><li>MIGRATION: Use <code>[base]</code> instead</li></ul></li><li>New placeholders for file-based templates (i. e. SourceMapDevToolPlugin)<ul><li><code>[name]</code></li><li><code>[base]</code></li><li><code>[path]</code></li><li><code>[ext]</code></li></ul></li><li><code>externals</code> when passing a function it has now a different signature <code>({ context, request }, callback)</code><ul><li>MIGRATION: Change signature</li></ul></li></ul><h3 id="更改默认值"><a href="#更改默认值" class="headerlink" title="更改默认值"></a>更改默认值</h3><ul><li><code>module.unsafeCache</code> is now only enabled for <code>node_modules</code> by default</li><li><code>optimization.moduleIds</code> defaults to <code>deterministic</code> in production mode instead of <code>size</code></li><li><code>optimization.chunkIds</code> defaults to <code>deterministic</code> in production mode instead of <code>total-size</code></li><li><code>optimization.nodeEnv</code> defaults to <code>false</code> in <code>none</code> mode</li><li><code>resolve(Loader).cache</code> defaults to <code>true</code> when a <code>cache</code> is used</li><li><code>resolve(Loader).cacheWithContext</code> defaults to <code>false</code></li><li><code>node.global</code> defaults to <code>false</code></li></ul><h2 id="主要的内部变化"><a href="#主要的内部变化" class="headerlink" title="主要的内部变化"></a>主要的内部变化</h2><p>下面的变化仅和你编写插件时相关：</p><h3 id="运行时模块"><a href="#运行时模块" class="headerlink" title="运行时模块"></a>运行时模块</h3><p>大部分运行时代码被移动到所谓的“运行时模块”中。这些特殊的模块添加了运行时代码。它们可以添加到任何块中，但目前始终添加到运行时块中。“Runtime requirements”控制将哪些运行时模块添加到bundle中。他确保只将使用的运行时代码添加到bundle中。在将来，运行时模块还可以添加到按需加载的块中，以在需要时加载运行时代码。</p><p>核心的运行时代码现在非常小，只包含<code>__webpack_require__</code>函数，模块工厂和模块实例缓存。将来可以使用替代代码来避免将bundle包装在IIFE中并允许ESM类型的导出。</p><p>迁移：在插件中请考虑使用RuntimeModules来将运行时代码注入到webpack运行时。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>添加了序列化机制以允许在webpack中序列化复杂对象。它具有可选语义，因此需要显式标记应该序列化的类。大多数模块，所有依赖项和一些错误已经实现该功能。</p><p>迁移：使用自定义模块或依赖项时，请确保它们可序列化，以从持久性缓存中受益。</p><h3 id="可扩展的缓存"><a href="#可扩展的缓存" class="headerlink" title="可扩展的缓存"></a>可扩展的缓存</h3><p>添加了具有插件接口的<code>Cache</code>类。此类可用于写入和读取缓存。根据配置，不同的插件会将功能添加到缓存中。<code>MemoryCachePlugin</code>添加了内存缓存。<code>FileCachePlugin</code>添加了持久性缓存。</p><p><code>FileCachePlugin</code>使用序列化机制来持久化缓存到硬盘中。</p><h3 id="Hook-object-frozen"><a href="#Hook-object-frozen" class="headerlink" title="Hook object frozen"></a>Hook object frozen</h3><p>带钩子的类使其钩子对象冻结，因此不再可能通过这种方式添加自定义钩子。</p><p>迁移： 推荐的添加自定义钩子的方法是通过WeakMap和一个静态的方法 <code>getXXXHooks(XXX)</code>（即getCompilationHook(compilation)）。内部类使用相同的机制来自定义钩子。</p><h3 id="移除Tapable的基础类"><a href="#移除Tapable的基础类" class="headerlink" title="移除Tapable的基础类"></a>移除Tapable的基础类</h3><p>删除webpack3插件的compat层，它已被webpack4抛弃。</p><p>迁移：使用tapable的新API。</p><h3 id="阶段性的钩子"><a href="#阶段性的钩子" class="headerlink" title="阶段性的钩子"></a>阶段性的钩子</h3><p>在运行过程中不同阶段有许多的钩子，即<code>optimizeDependenciesBasic</code>、<code>optimizeDependencies</code>和 <code>optimizeDependenciesAdvanced</code>。这些已经被删除，我们可以通过<code>stage</code>选项来使用单一的钩子。查看<br><code>OptimizationStages</code>以获取可能的值。</p><p>迁移：添加<code>stage</code>选项。</p><h3 id="order和ids"><a href="#order和ids" class="headerlink" title="order和ids"></a>order和ids</h3><p>webpack常常在编译阶段整理modules和chunks，这是一个特殊的方法来分配ids。</p><p>目前已不再是这种情况了。Order不再用于id的产生。 而是在插件中完全控制id生成。</p><p>已删除用于优化module和chunk顺序的挂钩。</p><p>迁移：你不能再依赖于编译中的module和chunk的顺序。</p><h3 id="数组到Set"><a href="#数组到Set" class="headerlink" title="数组到Set"></a>数组到Set</h3><ul><li>Compilation.modules 是Set类型</li><li>Compilation.chunks 是Set类型</li></ul><p>有一个复合层可以打印弃用警告。</p><p>迁移：使用Set方法取代Array方法</p><h3 id="Compilation-fileSystemInfo"><a href="#Compilation-fileSystemInfo" class="headerlink" title="Compilation.fileSystemInfo"></a>Compilation.fileSystemInfo</h3><p>这些类可以以缓存的方式访问文件系统信息。目前，它允许请求文件和目录时间戳。如果可能，有关时间戳的信息从观察者传输，否则由文件系统访问确定。将来会要求添加文件内容哈希，并且模块可以使用文件内容而不是文件哈希来检查有效性。</p><p>迁移：使用<code>compilation.fileSystemInfo</code>来代替<code>file/contextTimestamps</code></p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>HMR runtime已重构为runtime Modules。<code>HotUpdateChunkTemplate</code>已被合并到<code>ChunkTemplate</code>。ChunkTemplates 和插件也可以处理<code>HotUpdateChunks</code>。<br>HMR运行时的javascript部分已与核心HMR运行时分离。其他模块类型现在也可以以自己的方式处理HMR。将来允许HMR用来mini-css-extract-plugin 或 WASM模块。</p><p>迁移：由于这是一项新功能，以前没有实现，所以不需要迁移。</p><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p>webpack过去常常处理模块时使用函数调用函数以及限制并行性的信号量的方式。<code>Compilation.semaphore</code>已经被移除。异步队列来处理工作队列。每个步骤都有一个单独的队列：</p><ul><li><code>Compilation.factorizeQueue</code>:  为一组依赖项调用模块工厂</li><li><code>Compilation.addModuleQueue</code>: 将模块添加到编译中（可以从缓存中恢复模块）</li><li><code>Compilation.buildQueue</code>: 必要时构建模块（可以存储模块到缓存）</li><li><code>Compilation.rebuildQueue</code>: 如果手动触发，则再次构建模块</li><li><code>Compilation.processDependenciesQueue</code>: 处理模块的依赖</li></ul><p>这些队列有一些钩子可以监视和拦截工作进程。<br>将来，多个编译器可以协同工作，并且可以通过拦截这些队列来完成工作协调。</p><p>迁移：以前没有，无需迁移。</p><h3 id="Module-and-Chunk-Graph"><a href="#Module-and-Chunk-Graph" class="headerlink" title="Module and Chunk Graph"></a>Module and Chunk Graph</h3><p>webpack常常将将解析的模块存储在依赖中，将包含的模块存储在chunk中。现在已经不这样了。有关模块如何在模块图中连接的所有信息现在都存储在ModuleGraph类中。有关模块如何与块连接的所有信息都存储在ChunkGraph类中。依赖于chunk graph的信息也存储在相关类中。</p><p>这意味着已移动有关模块的以下信息：</p><ul><li>Module connections -&gt; ModuleGraph</li><li>Module issuer -&gt; ModuleGraph</li><li>Module optimization bailout -&gt; ModuleGraph (TODO check if it should ChunkGraph instead)</li><li>Module usedExports -&gt; ModuleGraph</li><li>Module pre order index -&gt; ModuleGraph</li><li>Module post order index -&gt; ModuleGraph</li><li>Module depth -&gt; ModuleGraph</li><li>Module profile -&gt; ModuleGraph</li><li>Module id -&gt; ChunkGraph</li><li>Module hash -&gt; ChunkGraph</li><li>Module runtime requirements -&gt; ChunkGraph</li><li>Module is in chunk -&gt; ChunkGraph</li><li>Module is entry in chunk -&gt; ChunkGraph</li><li>Module is runtime module in chunk -&gt; ChunkGraph</li><li>Chunk runtime requirements -&gt; ChunkGraph</li></ul><h3 id="初始化-fragments"><a href="#初始化-fragments" class="headerlink" title="初始化 fragments"></a>初始化 fragments</h3><p>已删除DependenciesBlockVariables以支持InitFragments。DependencyTemplates现在可以添加InitFragments以将代码注入模块源的顶部。InitFragments允许重复数据删除</p><h3 id="模块源类型"><a href="#模块源类型" class="headerlink" title="模块源类型"></a>模块源类型</h3><p>模块现在必须通过<code>Module.getSourceTypes（）</code>告诉它们支持哪些源类型。根据不同的插件，使用此类型调用<code>source（）</code> 即对于源类型<code>javascript</code> ，<code>JavascriptModulesPlugin</code>将源代码嵌入到bundle中。源类型<code>webassembly</code>将使<code>WebAssemblyModulesPlugin</code>释放一个wasm文件。自定义源类型是可能的，即<br>mini-css-extract-plugin可能会使用源类型<code>stylesheet</code>将源代码嵌入到css文件中。</p><p>模块类型和源类型之间没有关系。即模块类型<code>json</code>也使用源类型<code>javascript</code>和模块类型<code>webassembly / experimental</code>使用源类型<code>javascript</code>和<code>webassembly</code>。</p><p>迁移：自定义模块需要实现这些新的接口方法</p><h3 id="可扩展的统计数据"><a href="#可扩展的统计数据" class="headerlink" title="可扩展的统计数据"></a>可扩展的统计数据</h3><p>stats预设，默认，json，和tostring现在由插件系统提供。将当前的Stats转换为插件。</p><p>迁移：现在可以自定义它，而不是替换整个统计功能。现在可以将额外信息添加到统计信息json中，而不是写入单独的文件。</p><p><img style="display:block;margin:auto;" src="https://img11.360buyimg.com/imagetools/s300x300_jfs/t1/26011/22/7362/61668/5c6bace4Ee80973ef/4b4f8f550b8b13db.jpg"></p>]]></content>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack 4.0 新特性, Try it!</title>
      <link href="/2019/12/19/webpack4.0.0.beta/"/>
      <content type="html"><![CDATA[<p>webpack4.0.0.beta尝鲜</p><a id="more"></a><p>标签（空格分隔）： webpack</p><hr><p><img src="http://img14.360buyimg.com/uba/jfs/t18445/292/374093078/368389/7017a6b6/5a72b626Nc733221a.png" alt="此处输入图片的描述"><br>  近年来前端技术如雨后春笋蓬勃发展，我们也在不断学习中成长。例如：jsx 方便了我们在 js 中编写 html，less/sass 的出现提高了我们书写 css 的能力，AMD/CommonJS/ES6  的出现为我们模块化开发提供了便利。然而，我们需要使用其它工具将这些工具转化成原生语言以运行在浏览器上。但这样导致的问题就是代码体积越来越大，变的复杂不可控。于是，我们就开始考虑针对这些庞大的代码进行优化，webpack 就是这个需求下的产物。<br>  webpack 可以看做是模块打包机。它做的事情是：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。目前，webpack 总共发布了三个稳定版本。从17年八月底开始，经历了长达五个月的开发周期，webpack  团队通过增加大量新特性、bug修复、问题改善并于近期发布了 webpack4 的 beta 版本。如果你对 webpack 感兴趣，下面我们就来学习一下 webpack4 beta 的新特性。</p><p>P.S. 以下所有代码演示代码都是基于 webpack 4.0.0-beta.0</p><h2 id="一、安装webpack-v4-0-0-beta-0"><a href="#一、安装webpack-v4-0-0-beta-0" class="headerlink" title="一、安装webpack v4.0.0-beta.0"></a>一、安装webpack v4.0.0-beta.0</h2><p>如果你使用yarn<br><code>yarn add webpack@next webpack-cli --dev</code><br>如果你使用npm<br><code>npm install webpack@next webpack-cli --save-dev</code></p><h2 id="二、webpack-4-0-新特性介绍"><a href="#二、webpack-4-0-新特性介绍" class="headerlink" title="二、webpack 4.0 新特性介绍"></a>二、webpack 4.0 新特性介绍</h2><p>下面是一些你肯定会感兴趣的新特性。在阅读完本章之后，如果你觉得不过瘾，完整的修改列表请查看<a href="https://github.com/webpack/webpack/releases/tag/v4.0.0-beta.0" target="_blank" rel="noopener">官方修改日志</a><br><a href="https://github.com/webpack/webpack/releases/tag/v4.0.0-beta.0" target="_blank" rel="noopener">https://github.com/webpack/webpack/releases/tag/v4.0.0-beta.0</a></p><p>本章将从以下几部分来介绍 webpack 4.0。</p><h3 id="2-1-环境"><a href="#2-1-环境" class="headerlink" title="2.1 环境"></a>2.1 环境</h3><p>webpack 运行环境升级。已经不支持 Node.js 4 版本。源码升级到更高的 ECMAScript 版本。</p><blockquote><p>根据 webpack package.json 配置中显示 Node.js 最低支持版本：”node”: “&gt;=6.11.5”</p></blockquote><h3 id="2-2-模块"><a href="#2-2-模块" class="headerlink" title="2.2 模块"></a>2.2 模块</h3><h4 id="webpack-模块类型及-mjs-的支持："><a href="#webpack-模块类型及-mjs-的支持：" class="headerlink" title="webpack 模块类型及 .mjs 的支持："></a>webpack 模块类型及 .mjs 的支持：</h4><p>长久以来，JS是webapck中唯一的模块类型。正因此，开发者无法有效地打包其它类型的文件。目前，webpack实现了五种模块类型，它们各有自己的优势，可按需要使用（后面会详细说明）。</p><ol><li><code>javascript/auto</code>: (webpack3中默认)支持所有的JS模块系统：CommonJS、AMD、ESM。</li><li><code>javascript/esm</code>: EcmaScript模块，所有其他模块系统不可用（.mjs文件中默认）。</li><li><code>javascript/dynamic</code>: 不支持CommonJS和EcmaScript模块。</li><li><code>json</code>: JSON数据，可以通过require和import导入（.json文件默认）。</li><li><code>webassembly/experimental</code>: WebAssembly模式（目前处于实验性阶段，.wasm文件默认）。</li></ol><p>用法：<br>module.rules 中的 type 就是新增加的属性，用来支持不同的模块类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.special\.json$/,</span><br><span class="line">      type: &quot;javascript/auto&quot;,</span><br><span class="line">      use: &quot;special-loader&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>此外，现在webpack 按照 .wasm, .mjs, .js, 以及 .json 等扩展名的顺序来解析。</p><h4 id="javascript-esm-相比于-javascript-auto-处理ESM更加严格"><a href="#javascript-esm-相比于-javascript-auto-处理ESM更加严格" class="headerlink" title="javascript/esm 相比于 javascript/auto 处理ESM更加严格"></a><code>javascript/esm</code> 相比于 <code>javascript/auto</code> 处理ESM更加严格</h4><p>我们说既然有了 <code>javascript/auto</code>  为什么还要细分那么多其他类型呢？这是因为每种类型都有自己独特的处理优势。具体表现在两个方面：</p><ol><li>导入的名称必须存在于导入的模块中。</li><li>动态的模块（非ESM，例如CommonJS）只能通过默认 import 导入，其他所有（包括命名空间导入）的导入都会报错。</li></ol><h3 id="2-3-用法"><a href="#2-3-用法" class="headerlink" title="2.3 用法"></a>2.3 用法</h3><ul><li>必须在 “开发或者生产” 中选择一种模式（这里有一种隐藏模式 <code>none</code>，可以禁用一切功能）。<ul><li>生产模式不支持监听，开发模式针对快速增量重建进行了优化。</li><li>生产模式同样支持模块串联，即变量提升（此功能在webpack 3 中已经实现）。</li><li>开发模式下支持注释和提示，并且支持 eval 的source map。</li></ul></li><li>将 CLI 移动到 <code>webpack-cli</code> 中，你需要通过安装 <code>webpack-cli</code> 使用 CLI。</li><li>你可以使用 <code>optimization.*</code> 标志来配置自己的自定义模式。</li><li><code>webpackInclude</code> 和 <code>webpackExclude</code> 可以通过神奇的注释来支持 <code>import()</code> ，他们允许在使用动态表达式时过滤文件。</li><li>使用 <code>System.import()</code> 会发出警告:<ul><li>可以使用 <code>Rule.parser.system: true</code> 关闭警告。</li><li>你也可以使用 <code>Rule.parser.system: false</code> 关闭 <code>System.import()</code>。</li></ul></li><li>对于迁移到新的插件系统的插件 <code>ProgressPlugin</code> 现在显示插件名称。</li><li>webpack 现在可以本地处理 JSON。如果用 loader 转换 json 为 js，需要设置：<code>type: &quot;javascript/auto&quot;</code>。当然，不用 loader webpack 依然可以正常工作。</li></ul><h3 id="2-4-配置"><a href="#2-4-配置" class="headerlink" title="2.4 配置"></a>2.4 配置</h3><ul><li>删除了一些常用内置插件：<ul><li><code>NoEmitOnErrorsPlugin</code> -&gt; <code>optimization.noEmitOnErrors</code> (生产模式默认)</li><li><code>ModuleConcatenationPlugin</code> -&gt; <code>optimization.concatenateModules</code> （生产模式默认）</li><li><code>NamedModulesPlugin</code> -&gt; <code>optimization.namedModules</code> （开发模式默认）</li><li><strong>删除了常用的<code>CommonsChunkPlugin</code> -&gt; <code>optimization.splitChunks</code></strong>对于那些需要细粒度控制缓存策略的人，可以通过 optimization.splitChunks和optimization.runtimeChunk。</li></ul></li><li>现在可以使用module.rules[].resolve来配置解析。它与全局配置合并</li><li><code>optimization.minimize</code> 用于控制minimizing的开关。<ul><li>生产模式默认为开，开发模式默认为关。</li></ul></li><li><code>optimization.minimizer</code> 用于配置minimizers和选项。</li><li>许多支持占位符的配置选项现在也支持函数形式。</li><li>错误的 <code>options.dependencies</code> 配置现在会抛出异常。</li><li><code>sideEffects</code> 可以通过 <code>module.rules</code> 覆盖。</li><li>添加 <code>output.globalObject</code> 配置选项以允许在运行时选择全局对象引用。</li><li>无需显式设置entry和output属性，webpack默认设置entry属性为./src，output的属性为./dist。</li><li>移除module.loaders。</li></ul><h3 id="2-5-优化"><a href="#2-5-优化" class="headerlink" title="2.5 优化"></a>2.5 优化</h3><ul><li>uglifyjs-webpack-plugin 升级到了 v1，并且支持 ES6语法。</li><li>可以在 package.json 中配置<code>sideEffects: false</code> 。当设置这个字段之后，标识在使用的库里没有任何副作用。这意味着webpack可以从代码中安全地清除任何re-exports。</li><li>使用JSONP数组来代替JSONP函数 –&gt; 异步支持。</li><li>引入新的 <code>optimization.splitChunks</code> 选项。</li><li>webpack 可以删除无用代码，之前是由 Uglify 删除无用的代码，现在 webpack 也可以删除无用的代码。这可以有效防止在 import 无用的代码之后发生的崩溃。</li></ul><p>以下是一些内部优化：</p><ul><li>用 tap 调用替换 plugin 调用（新的插件系统）</li><li>将许多废弃的插件迁移到新的插件系统API</li><li>为 json 模块添加了 <code>buildMeta.exportsType: &quot;default&quot;</code></li><li>删除了 <code>Parser (parserStringArray, parserCalculatedStringArray)</code> 中未使用的方法</li></ul><h3 id="2-6-性能"><a href="#2-6-性能" class="headerlink" title="2.6 性能"></a>2.6 性能</h3><ul><li>默认情况，UglifyJS 默认缓存和并行化（并未完全实现缓存和并行化，webpack5的里程碑）。</li><li>发布了一个新版本的插件系统，所以事件钩子和处理程序变的单一化。</li><li>多个性能改进，特别是更快的增量重建。</li><li>改进了RemoveParentModluesPlugin的性能。</li></ul><h3 id="2-7-破坏性的改变（插件、loader相关）"><a href="#2-7-破坏性的改变（插件、loader相关）" class="headerlink" title="2.7 破坏性的改变（插件、loader相关）"></a>2.7 <strong>破坏性的改变（插件、loader相关）</strong></h3><ul><li>新的插件系统<ul><li>插件方法是向后兼容的</li><li>插件现在应该这样使用 <code>Compiler.hooks.xxx.tap(&lt;plugin name&gt;, fn)</code></li></ul></li><li><code>Chunk.chunks/parents/blocks</code> 不再是数组。在内部使用一个集合，并且有方法来访问它。</li><li><code>Parser.scope.renames</code> 和 <code>Parser.scope.definitions</code> 不再是对象/数组，而是Map/Set。</li><li>解析器使用 <code>StackedSetMap</code>（类似于LevelDB的数据结构）而不是数组。</li><li>在应用插件时不再设置 <code>Compiler.options</code>。</li><li>所有模块的构造参数都发生了变化。</li><li>将 <code>options</code> 合并到 <code>ContextModule</code> 和 <code>resolveDependencies</code> 的 <code>options</code> 对象中.</li><li>更改并重命名 <code>import()</code> 的依赖关系</li><li>将 <code>Compiler.resolvers</code> 移入可通过插件访问的 <code>Compiler.resolverFactory</code>中。</li><li><code>Dependency.isEqualResource</code> 已被替换为 <code>Dependency.getResourceIdentifier</code></li><li><code>Template</code> 方法都是静态的。</li><li>已经添加了一个新的 <code>RuntimeTemplate</code> 类，<code>outputOptions</code> 和 <code>requestShortener</code> 已经被移动到这个类中。<ul><li>已经更新了许多方法来代替 <code>RuntimeTemplate</code> 的使用。</li><li>我们计划将访问运行时的代码移动到这个新类中</li></ul></li><li>Module.meta已被Module.buildMeta所取代</li><li>已添加Module.buildInfo和Module.factoryMeta</li><li>Module的一些属性已经被移动到新的对象中</li><li>添加指向上下文选项的 <code>loaderContext.rootContext</code>。<code>loaders</code> 可以使用它来创建相对于应用程序根目录的东西。</li><li>当启用HMR时，将 <code>this.hot</code> 标志添加到 loader 上下文中。</li><li><code>buildMeta.harmony</code> 已被替换为 <code>buildMeta.exportsType：namespace</code>。</li><li>chunk 图已经改变：<ul><li>之前：Chunks 的连接与嵌套依赖关系有关。</li><li>现在：ChunksGroups 的连接与引用依赖有关，按照顺序串联。</li><li>之前：AsyncDependenciesBlocks 按顺序引用 Chunks 列表。</li><li>现在：AsyncDependenciesBlocks 引用一个 ChunkGroup。</li></ul></li></ul><p>★★ 注意：以上内容都是关于 loaders、plugins 重大的变化。</p><h2 id="三、重点更新详解"><a href="#三、重点更新详解" class="headerlink" title="三、重点更新详解"></a>三、重点更新详解</h2><h3 id="3-1-更好的默认值"><a href="#3-1-更好的默认值" class="headerlink" title="3.1 更好的默认值"></a>3.1 更好的默认值</h3><p>直到今日，webpack 总是要求显式地设置 <code>entry</code> 和 <code>output</code> 属性。webpack4 中，webpack 会自动设定你的 <code>entry</code> 属性为 <code>./src</code> 以及 <code>output</code> 的属性为 <code>./dist</code>。<br>这意味着您<strong>不再需要配置文件</strong>来启动 webpack。接下来我们为你演示 webpack 4 的便捷操作：</p><p>1、我们需要安装好 webpack 之后，在 package.json 中添加如下脚本即可启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>2、在工程中添加简单示例代码如下图（整个工程没有 webpack 配置文件，即可运行打包）：<br><img src="https://raw.githubusercontent.com/wangjianhui2464/JavaScript-Example/master/assets/img/no-config-eg.jpg" alt="无配置示例"><br>(图1，图中示例代码为 webpack3 官网示例)</p><p>3、打包过程中我们发现有新特性的提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING in configuration</span><br><span class="line">The &apos;mode&apos; option has not been set. Set &apos;mode&apos; option to &apos;development&apos; or &apos;production&apos; to enable defaults for this environment.</span><br></pre></td></tr></table></figure></p><p>这就是我们下节要说的内容<strong>模式设置</strong>。</p><p>★★ 注意：入口默认为 <code>./src</code> 如果缺少此文件夹会报错！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; webpack --mode production</span><br><span class="line"></span><br><span class="line">ERROR in Entry module not found: Error: Can&apos;t resolve &apos;./src&apos; in &apos;D:\workspace\github\Webpack-Example&apos;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-模式设置"><a href="#3-2-模式设置" class="headerlink" title="3.2 模式设置"></a>3.2 模式设置</h3><p>以往的项目使用 webpack3 脚手架生成项目初始模板都会有两个甚至三个配置文件，比如<br><code>webpack.base.conf.js</code>、<code>webpack.prod.conf.js</code>、<code>webpack.dev.conf.js</code> 而现在可以做到一个配置文件都不需要，直接在启动命令中传入参数 <code>--mode development | production</code> 达到区分不同模式的效果。</p><p>接下来修改 package.json 设置不同的模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack --mode development&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>重新执行 <code>npm run dev</code> 或 <code>npm run build</code> 即可看到不同的打包结果：<br><img src="https://raw.githubusercontent.com/wangjianhui2464/JavaScript-Example/master/assets/img/mode-dev-prod.png" alt="不同模式打包"><br>我们可以看到两种模式的结果完全不同，下面我们会更深入的按照我们真实的需求来讲解一些常用配置。</p><p>接下来这个配置是最常用到的，我们使用 webpack 的主要目的之一就是为了更好的支撑前段模块化的能力，既然需要模块化当然少不了代码分割，目前代码分割有以下几种：</p><ol><li>通过 <code>entry</code> 分割不同入口，常用于多页应用；</li><li>通过 <code>CommonsChunkPlugin</code> 插件来分割不同功能模块；</li><li>通过动态 <code>import</code> 来分割。<br>下面我们主要讲解 webpack 4 版本的重大变化删除了 <code>CommonsChunkPlugin</code> 插件。</li></ol><h3 id="3-3-删除-CommonsChunkPlugin"><a href="#3-3-删除-CommonsChunkPlugin" class="headerlink" title="3.3 删除 CommonsChunkPlugin"></a>3.3 删除 CommonsChunkPlugin</h3><blockquote><p>webpack 4 删除了 <code>CommonsChunkPlugin</code>，以支持两个新的选项（<code>optimization.splitChunks</code> 和 <code>optimization.runtimeChunk</code>）。</p></blockquote><p>从 4.0 开始分割 <code>Chunk</code> 将不在使用 <code>CommonsChunkPlugin</code> 插件，而是使用 <code>optimization</code> 配置项，具体的实现原理可以参考：<a href="https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693" target="_blank" rel="noopener">https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693</a></p><p>由于还没有正式官方文档出来，以下是我们通过实践出的 <code>optimization</code> 配置方法：<br>其中用到了新增的 <code>splitChunks</code> 属性，此属性看字面意思就明白是分割代码块的选项，其下可配置项已在下面示例代码中列出（有兴趣的朋友可以自行实践）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  vendor: [&apos;lodash&apos;]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &quot;initial&quot;,         // 必须三选一： &quot;initial&quot; | &quot;all&quot;(默认就是all) | &quot;async&quot; </span><br><span class="line">      minSize: 0,                // 最小尺寸，默认0</span><br><span class="line">      minChunks: 1,              // 最小 chunk ，默认1</span><br><span class="line">      maxAsyncRequests: 1,       // 最大异步请求数， 默认1</span><br><span class="line">      maxInitialRequests : 1,    // 最大初始化请求书，默认1</span><br><span class="line">      name: ()=&gt;&#123;&#125;,              // 名称，此选项课接收 function</span><br><span class="line">      cacheGroups:&#123;                 // 这里开始设置缓存的 chunks</span><br><span class="line">        priority: &quot;0&quot;,              // 缓存组优先级</span><br><span class="line">        vendor: &#123;                   // key 为entry中定义的 入口名称</span><br><span class="line">          chunks: &quot;initial&quot;,        // 必须三选一： &quot;initial&quot; | &quot;all&quot; | &quot;async&quot;(默认就是异步) </span><br><span class="line">          test: /react|lodash/,     // 正则规则验证，如果符合就提取 chunk</span><br><span class="line">          name: &quot;vendor&quot;,           // 要缓存的 分隔出来的 chunk 名称</span><br><span class="line">          minSize: 0,</span><br><span class="line">          minChunks: 1,</span><br><span class="line">          enforce: true,</span><br><span class="line">          maxAsyncRequests: 1,       // 最大异步请求数， 默认1</span><br><span class="line">          maxInitialRequests : 1,    // 最大初始化请求书，默认1</span><br><span class="line">          reuseExistingChunk: true   // 可设置是否重用该chunk（查看源码没有发现默认值）</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>以上就是 <code>optimization.splitChunks</code> 的所有可用的配置项属性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我们初步整理的关于 webpack 4 的新特性，包含了一部分的官方更新日志的翻译，还有我们自己试验的一些属性。当然如果你有兴趣，也可以等到正式的官方文档发布之后进行实践。</p><p>如果上面的信息不能够完全满足你的兴趣，还请关注官方日志。在未来不到一个月的时间里，webpack 将对插件、加载器以及整个生态系统进行更加严格的测试，并发布最终的官方稳定版本。如果你喜欢 webpack，你可以参与使用 webpack4.0.0.beta，如果提出的问题越多，便可以为大家提供更加稳定的版本。</p><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><p><a href="https://github.com/jdf2e/webpack4-demo" target="_blank" rel="noopener">京东前端</a></p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><hr><p><a href="https://medium.com/webpack/webpack-4-beta-try-it-today-6b1d27d7d7e2" target="_blank" rel="noopener">webpack 4 beta — try it today! . Sean T. Larkin</a><br><a href="https://github.com/webpack/webpack/releases/tag/v4.0.0-beta.0" target="_blank" rel="noopener">webpack v4.0.0-beta.0 release . Tobias Koppers</a><br><a href="https://github.com/webpack/webpack/issues/6357" target="_blank" rel="noopener">webpack 4.0.0-alpha.5 feedback . Tobias Koppers</a></p><p><img style="display:block;margin:auto;" src="https://img11.360buyimg.com/imagetools/s300x300_jfs/t1/26011/22/7362/61668/5c6bace4Ee80973ef/4b4f8f550b8b13db.jpg"></p>]]></content>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
